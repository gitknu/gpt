<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–Ø–∫ —Å—Ç–≤–æ—Ä–∏—Ç–∏ GPT</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- Updated to include font-weight 800 for extrabold -->
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;800&display=swap" rel="stylesheet">
<style>
    body, html {
        height: 100%;
        margin: 0;
        padding: 0;
        background-color: white;
        display: flex;
        flex-direction: column; /* Stack items vertically */
        font-family: sans-serif;
        box-sizing: border-box; /* Ensure padding/borders don't add to height */
    }

    .top-group {
        width: 100%;
        padding: 0 80px; /* --- EDITED: Increased horizontal padding --- */
        margin-top: 20px;
        box-sizing: border-box; /* Include padding in width */
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }


    /* New title style */
    .data-title-container {
        font-family: 'Montserrat', sans-serif;
        color: black;
        margin: 0;
        height: 86px; /* 1/7th of original 600px */
        display: flex;
        flex-direction: column;
        justify-content: center; /* Vertically center the text block */
        overflow: hidden; /* Added to clip the text during transition */
        user-select: none; /* ADDED: Prevent text selection on click */
        align-self: center; /* CHANGED: Center the title block */
        align-items: center; /* ADDED: Center the text lines inside */
    }

    .title-en {
        font-weight: 800; /* Extrabold */
        font-size: 2rem; /* 32px */
        line-height: 1.2;
        text-align: center; /* --- ADDED --- */
        color: #b80000;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    }

    .title-ua {
        font-weight: 800; /* Extrabold - CHANGED */
        font-size: 1.1rem; /* 17.6px - CHANGED (adjusted to match width with new weight) */
        line-height: 1.2;
        text-align: center;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    }

    .scroller-hint {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500; /* Not bold, as requested */
        font-size: 0.675rem; /* 75% of original 0.9rem */
        color: #cccccc; /* Barely visible grey color */
        margin-top: 8px; /* Space from title */
        margin-bottom: 0; /* No extra space, scroller has its own */
        align-self: center;
        text-align: center;
        user-select: none;
    }

    .scroller-hint .arrow-left {
        display: inline; /* Show left arrow by default (scroller is on the left) */
    }
    .scroller-hint .arrow-right {
        display: none; /* Hide right arrow by default */
    }

    .top-group.right .scroller-hint .arrow-left {
        display: none; /* Hide left arrow when scroller is on the right */
    }
    .top-group.right .scroller-hint .arrow-right {
        display: inline; /* Show right arrow when scroller is on the right */
    }

    .main-content-wrapper {
        flex-grow: 1; /* This wrapper fills the vertical space */
        width: 100%;
        box-sizing: border-box;
        margin: 10px 0 0 0;
        padding: 0 80px; /* --- EDITED: Increased horizontal padding --- */
        position: relative; /* CRITICAL: For absolute positioning child */
    }
/* --- END: EDITED BY GEMINI --- */


    /* --- START: Scroller Styles --- */
/* --- START: EDITED BY GEMINI --- */
    .scroller-container {
        margin-top: 0;
        height: 514px; /* 6/7ths of original 600px */
        width: 9px;
        background-color: transparent;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        position: absolute; /* CRITICAL: Now absolutely positioned */
        top: 0; /* Align to top of wrapper */
        left: 80px; /* --- EDITED: Matched new padding --- */
        transition: left 0.4s cubic-bezier(0.65, 0, 0.35, 1);
    }

    .scroller-container::before {
        content: '';
        position: absolute;
        width: 4px;
        height: 100%;
        background-color: black;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1;
    }

    .thick-segment {
        position: absolute;
        width: 4px; /* Start at thin width */
        background-color: black;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2; /* Above thin line */
        height: 0; /* Controlled by JS */
        top: 0; /* Controlled by JS */
        transition: width 0.3s cubic-bezier(0.65, 0, 0.35, 1);
    }

    .thick-segment.active {
        width: 9px; /* Animate to thick width */
    }

    .dot {
        width: 20px;
        height: 20px;
        background-color: black;
        border-radius: 50%;
        flex-shrink: 0;
        position: relative;
        z-index: 3; /* Above thick line */
    }

    #scroller-handle {
        width: 36px; /* This is the outer black dot */
        height: 36px;
        background-color: black;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        transform: translate(-50%, -50%) scale(1);
        cursor: grab;
        transition: top 0.4s cubic-bezier(0.65, 0, 0.35, 1),
                    transform 0.3s cubic-bezier(0.65, 0, 0.35, 1);
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 4; /* Topmost element */
    }

    #scroller-handle::before {
        content: '';
        display: block;
        width: 18px;
        height: 18px;
        background-color: #0b5394; /* The blue liquid */
        border-radius: 50%;
        transform: scale(1);
        transition: transform 0.3s cubic-bezier(0.65, 0, 0.35, 1);
    }

    #scroller-handle.grabbing {
        transform: translate(-50%, -50%) scaleX(0.25) scaleY(1);
        cursor: grabbing;
    }

    #scroller-handle.grabbing::before {
        transform: scaleX(2) scaleY(0.5);
    }

    /* --- ADDED: This is the "flowing" state --- */
    #scroller-handle.grabbing.flowing::before {
        transform: scaleX(2) scaleY(2.0);
    }

    #scroller-handle:active {
        cursor: grabbing;
    }

    .working-area {
        border: 2px dashed black;
        border-radius: 10px;
        /* CRITICAL: Set fixed margins on BOTH sides */
        margin-left: 24px;
        margin-right: 24px;
        /* ADDED: Set height to match scroller */
        height: 514px;
        box-sizing: border-box; /* Account for border */
        /* --- START: Added by Gemini for visualization --- */
        padding: 20px;
        font-family: 'Courier New', Courier, monospace;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Hide overflow from animations */
        /* --- END: Added by Gemini for visualization --- */
    }

    .main-content-wrapper.right .scroller-container {
        left: calc(100% - 80px - 9px); /* --- EDITED: Matched new padding --- */
    }

    .logo-container {
        display: flex;
        flex-direction: row;
        align-items: flex-end;
        gap: 20px;
        margin-bottom: 20px;
        width: 100%;
        justify-content: center;
        margin-top: auto; /* Pushes logos to the bottom */
        box-sizing: border-box;
        padding: 0 40px; /* --- ADDED: Give logos original padding --- */
    }
/* --- END: EDITED BY GEMINI --- */

    .logo-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }

    .logo-label {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500;
        font-size: 16px;
        color: #333;
        margin-bottom: 10px; /* Space between text and logo */
    }

    .logo-link {
        display: inline-block;
    }

    .logo {
        width: 150px; /* Adjust size as needed */
        height: auto;
        transition: transform 0.2s ease-in-out;
    }

    .logo:hover {
        transform: scale(1.1);
    }

    /* --- START: Data Visualization Styles (Enhanced by Gemini) --- */
    .data-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center; /* Center the whole viz */
        font-family: 'Montserrat', sans-serif;
        color: black;
    }

    .vis-main-area {
        width: 100%;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between; /* Space out rows */
        align-items: center;
        position: relative; /* For absolute positioning of animated elements */
        min-height: 0; /* Fix for flex overflow */
    }

    /* Row for the source websites */
    .vis-sources-row {
        display: flex;
        justify-content: center;
        gap: 30px;
        width: 100%;
    }
    .vis-source {
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: transform 0.3s, opacity 0.3s;
    }
    .vis-source-icon {
        font-size: 2.5rem;
    }
    .vis-source-url {
        font-size: 0.7rem;
        margin-top: 5px;
        font-family: 'Courier New', Courier, monospace;
    }
    .vis-source.pending {
        opacity: 0.4;
    }
    .vis-source.active {
        transform: scale(1.1);
        font-weight: bold;
    }
    .vis-source.done {
        opacity: 0.2;
    }

    /* The central scraper icon */
    .vis-scraper-icon {
        font-size: 4rem;
        animation: gentle-bob 2s infinite ease-in-out;
    }
    @keyframes gentle-bob {
        0% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0); }
    }

    /* The storage icon at the bottom */
    .vis-storage-icon {
        font-size: 3.5rem;
    }

    /* The animated data packet */
    .vis-data-packet {
        position: absolute;
        font-size: 2rem;
        opacity: 0;
        z-index: 10;
        /* JS will control top, left and transitions */
    }


    .vis-log {
        margin-top: 15px;
        height: 100px; /* Fixed height for log area */
        width: 100%;
        border-top: 1px solid #eee; /* A subtle separator instead of a full border */
        padding-top: 10px;
        overflow-y: auto;
        font-size: 0.85rem;
        font-family: 'Courier New', Courier, monospace;
        flex-shrink: 0; /* Prevent log from shrinking */
    }
    .vis-log-entry {
        margin-bottom: 5px;
    }
    /* --- END: Data Visualization Styles --- */


    /* --- Mobile Responsivity --- */
    @media (max-width: 600px) {

        /* Adjust top group for mobile */
        .top-group {
            padding: 0 40px; /* --- EDITED: Increased horizontal padding for mobile --- */
            margin-top: 10px;
        }

        /* Adjust title for mobile */
        .data-title-container {
            height: 57px; /* 1/7th of original 400px */
        }

        .title-en {
            font-size: 1.5rem; /* 24px */
        }

        .title-ua {
            font-size: 0.83rem; /* 13.28px - CHANGED (adjusted to match mobile width with new weight) */
        }

        /* --- ADDED: Mobile hint styles --- */
        .scroller-hint {
            font-size: 0.6rem; /* 75% of 0.8rem */
            margin-top: 4px;
        }

/* --- START: EDITED BY GEMINI --- */
        .main-content-wrapper {
            margin: 10px 0 0 0;
            padding: 0 40px; /* --- EDITED: Increased horizontal padding for mobile --- */
        }

        .scroller-container {
            margin-top: 0;
            height: 343px; /* 6/7ths of original 400px */
            left: 40px; /* --- EDITED: Matched new mobile padding --- */
        }

        /* CRITICAL: Mobile rule for scroller on the right */
        .main-content-wrapper.right .scroller-container {
            left: calc(100% - 40px - 9px); /* --- EDITED: Matched new mobile padding --- */
        }
/* --- END: EDITED BY GEMINI --- */

        .dot {
            width: 16px;
            height: 16px;
        }

        #scroller-handle {
            width: 24px;
            height: 24px;
        }

        #scroller-handle::before {
            width: 10px;
            height: 10px;
        }

/* --- START: EDITED BY GEMINI --- */
        /* --- ADDED: Mobile style for working area --- */
        .working-area {
            /* CRITICAL: Set fixed margins on BOTH sides for mobile */
            margin-left: 12px; /* Half of desktop */
            margin-right: 12px; /* Half of desktop */
            /* ADDED: Set height to match mobile scroller */
            height: 343px;
            box-sizing: border-box;
            /* --- START: Added by Gemini for visualization (mobile) --- */
            padding: 10px;
            font-size: 0.8rem;
            /* --- END: Added by Gemini for visualization (mobile) --- */
        }
        
        /* --- START: Updated by Gemini for better mobile fit --- */
        .vis-sources-row {
            gap: 15px; /* Less space between icons on mobile */
        }
        .vis-source-icon {
            font-size: 2rem;
        }
        .vis-source-url {
            font-size: 0.6rem; /* Smaller text for URL */
        }
        .vis-scraper-icon {
            font-size: 3rem;
        }
        .vis-storage-icon {
            font-size: 3rem;
        }
        .vis-log {
            height: 60px;
            font-size: 0.75rem;
            margin-top: 10px;
        }
        /* --- END: Updated by Gemini for better mobile fit --- */

        /* REMOVED: .main-content-wrapper.right .working-area rule */
/* --- END: EDITED BY GEMINI --- */


/* --- START: EDITED BY GEMINI --- */
        .logo-container {
            padding: 0 20px 20px; /* --- EDITED: Reverted to original mobile padding --- */
            margin-bottom: 0;
            gap: 15px;
            flex-wrap: wrap; /* --- ADDED: Prevents horizontal overflow --- */
        }
/* --- END: EDITED BY GEMINI --- */
        .logo {
            width: 90px; /* Logos size on mobile */
        }
        .logo-label {
            font-size: 14px; /* Slightly smaller text on mobile */
        }
    }
</style>
</head>
<body>

<!-- Top content group -->
<div class="top-group">
    <!-- Updated title structure -->
    <div class="data-title-container">
        <!-- This text will be updated by the script -->
        <!-- Set initial text to Level 1 (which is now at the bottom) -->
        <span class="title-en">Data collection:</span>
        <span class="title-ua">–ø—Ä–æ—Ü–µ—Å –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö</span>
    </div>

    <!-- --- MODIFIED: New hint text with spans for arrows --- -->
    <p class="scroller-hint">
        <i>
            <span class="arrow-left">‚Ü∂</span>
            –º–æ–∂–Ω–∞ –ø–æ—Ç—è–≥–Ω—É—Ç–∏ –Ω–∞ —ñ–Ω—à–∏–π –±—ñ–∫ –µ–∫—Ä–∞–Ω—É
            <span class="arrow-right">‚Ü∑</span>
        </i>
    </p>
</div>

<!-- New wrapper for scroller and content -->
<div class="main-content-wrapper">
    <!-- Scroller is now here -->
    <!-- Its position is controlled by position:absolute -->
    <div class="scroller-container">
        <!-- ADDED: 6 segments for the 6 gaps between 7 dots -->
        <div class="thick-segment" id="segment-0"></div>
        <div class="thick-segment" id="segment-1"></div>
        <div class="thick-segment" id="segment-2"></div>
        <div class="thick-segment" id="segment-3"></div>
        <div class="thick-segment" id="segment-4"></div>
        <div class="thick-segment" id="segment-5"></div>

        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <!-- REMOVED: #thick-line-segment -->
        <div id="scroller-handle"></div>
    </div>

    <!-- Dashed box is now here -->
    <!-- Its position is fixed by its own margins -->
    <div class="working-area"></div>
</div>


<!-- Logo content is placed here, positioned at the bottom by the body's flex settings -->
<div class="logo-container">
    <div class="logo-item">
        <p class="logo-label">–ö–æ–º–ø'—é—Ç–µ—Ä</p>
        <a href="https://ollama.com" target="_blank" class="logo-link">
            <img src="https://gitknu.github.io/gpt/files/ollama.png" alt="Ollama Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=Ollama';">
        </a>
    </div>
    <div class="logo-item">
        <p class="logo-label">–°–º–∞—Ä—Ç—Ñ–æ–Ω</p>
        <a href="https://play.google.com/store/apps/details?id=com.pocketpalai" target="_blank" class="logo-link" id="pocketpal-link">
            <img src="https://gitknu.github.io/gpt/files/pocketpal.png" alt="PocketPal Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=PocketPal';">
        </a>
    </div>
    <div class="logo-item">
        <p class="logo-label">–í–ª–∞—Å–Ω–∞ –ê–Ü</p>
        <a href="https://github.com/theaniketgiri/create-llm" target="_blank" class="logo-link">
            <img src="https://gitknu.github.io/gpt/files/github.png" alt="GitHub Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=GitHub';">
        </a>
    </div>
</div>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        // --- START: PocketPal Link Logic ---
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const pocketpalLink = document.getElementById("pocketpal-link");

        // Check for iOS/iPadOS
        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            pocketpalLink.href = "https://apps.apple.com/us/app/pocketpal-ai/id6502579498";
        }
        // Check for MacOS
        else if (/Macintosh|MacIntel|MacPPC|Mac68K/.test(userAgent)) {
            pocketpalLink.href = "https://apps.apple.com/us/app/pocketpal-ai/id6502579498";
        }
        // --- END: PocketPal Link Logic ---

        const scrollerContainer = document.querySelector('.scroller-container');
        const mainContentWrapper = document.querySelector('.main-content-wrapper');
        const topGroup = document.querySelector('.top-group');


        // --- START: Text Data for Scroller (INVERTED) ---
        const levelData = [
            // Index 0 (Top Dot) is now Level 7
            { en: "RLHF:", ua: "–Ω–∞–≤—á–∞–Ω–Ω—è –ø–æ –≤—ñ–¥–≥—É–∫–∞—Ö" },
            { en: "Reward model training:", ua: "—Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏" },
            { en: "Supervised finetuning:", ua: "–¥–æ–Ω–∞–≤—á–∞–Ω–Ω—è (–∑—ñ –≤—á–∏—Ç–µ–ª–µ–º)" },
            { en: "Unsupervised pretraining:", ua: "–ø–æ–ø–µ—Ä–µ–¥–Ω—î –Ω–∞–≤—á–∞–Ω–Ω—è (–±–µ–∑ –≤—á–∏—Ç–µ–ª—è)" },
            { en: "Tokenization:", ua: "—Ä–æ–∑–±–∏—Ç—Ç—è –Ω–∞ —Ç–æ–∫–µ–Ω–∏" },
            { en: "Preprocessing:", ua: "–ø–æ–ø–µ—Ä–µ–¥–Ω—è –æ–±—Ä–æ–±–∫–∞" },
            // Index 6 (Bottom Dot) is now Level 1
            { en: "Data collection:", ua: "–ø—Ä–æ—Ü–µ—Å –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö" }
        ];

        const titleEn = document.querySelector('.title-en');
        const titleUa = document.querySelector('.title-ua');
        // Set initial level index to 6 (Bottom dot, which is now Level 1)
        let currentLevelIndex = 6; // Keep track of the current level
        let previousLevelIndex = 6; // --- ADDED: Keep track of previous dot
        // --- END: Text Data for Scroller ---


        // --- START: Scroller Logic ---
        const handle = document.getElementById('scroller-handle');
        const scroller = handle.parentElement; // This is the scroller-container
        const dots = Array.from(scroller.getElementsByClassName('dot'));
        // --- ADDED: Get all segments ---
        const segments = Array.from(scroller.getElementsByClassName('thick-segment'));
        // --- REMOVED: thickLine ---
        let isDragging = false;
        let flowTimer; // --- ADDED: Timer for flow animation

        // --- NEW DRAG LOGIC VARS ---
        let startX = 0;
        let startY = 0;
        let dragMode = 'none'; // 'none', 'pending', 'vertical', 'horizontal'
        // --- END NEW VARS ---

        const dotPositions = dots.map(dot => dot.offsetTop + dot.offsetHeight / 2);

        // --- START: Added by Gemini (Visualization Vars) ---
        let isVisRunning = false;
        const workingArea = document.querySelector('.working-area');
        // --- END: Added by Gemini ---


        // Set initial position of the handle to the *last* dot (bottom)
        handle.style.top = `${dotPositions[dotPositions.length - 1]}px`;

        // --- START: Added by Gemini (Visualization Functions) ---
        
        // Simple helper to create a delay
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Function to add entries to the visualization log
        function addToVisLog(logArea, message) {
            const entry = document.createElement('div');
            entry.className = 'vis-log-entry';
            entry.textContent = `> ${message}`;
            logArea.appendChild(entry);
            // Auto-scroll to bottom
            logArea.scrollTop = logArea.scrollHeight;
        }

        // Function to clear the visualization
        function clearDataCollectionVisualization() {
            workingArea.innerHTML = '';
            isVisRunning = false; // Allow a new visualization to start
        }

        // --- START: EDITED BY GEMINI ---
        // Function to start and run the data collection visualization
        async function startDataCollectionVisualization() {
            // Prevent multiple instances from running
            if (isVisRunning) return;
            isVisRunning = true;

            // 1. Define the sites to scrape
            const sitesToScrape = [
                { id: "site-1", url: "news.com" },
                { id: "site-2", url: "reviews.com" },
                { id: "site-3", url: "blog.org" },
                { id: "site-4", url: "shop.net" }
            ];

            // 2. Create the HTML structure for the new visualization (This happens only once)
            workingArea.innerHTML = `
                <div class="data-vis-container">
                    <div class="vis-main-area" id="vis-main-area">
                        
                        <!-- Row 1: Source Websites -->
                        <div class="vis-sources-row">
                            ${sitesToScrape.map(site => `
                                <div class="vis-source pending" id="${site.id}">
                                    <div class="vis-source-icon">üåê</div>
                                    <div class="vis-source-url">${site.url}</div>
                                </div>
                            `).join('')}
                        </div>

                        <!-- Row 2: Scraper Icon -->
                        <div id="vis-scraper-container">
                            <div class="vis-scraper-icon">üï∑Ô∏è</div>
                        </div>

                        <!-- Row 3: Storage Icon -->
                        <div id="vis-storage-container">
                             <div class="vis-storage-icon">üóÑÔ∏è</div>
                        </div>

                    </div>
                    <div class="vis-log" id="vis-log"></div>
                </div>
            `;

            // 3. Get references to the new elements
            const logArea = document.getElementById('vis-log');
            const mainArea = document.getElementById('vis-main-area');
            const scraperContainer = document.getElementById('vis-scraper-container');
            const storageContainer = document.getElementById('vis-storage-container');
            const visContainer = workingArea.querySelector('.data-vis-container');
            
            // 4. Start the eternal animation loop. It will only stop if isVisRunning becomes false.
            while (isVisRunning) {

                // --- A. Run one full animation cycle ---
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ –∑–∞–¥–∞—á—É –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö...");
                await wait(1000);

                for (const site of sitesToScrape) {
                    if (!isVisRunning) break; 

                    const sourceElement = document.getElementById(site.id);
                    sourceElement.classList.remove('pending');
                    sourceElement.classList.add('active');
                    addToVisLog(logArea, `–ü—ñ–¥–∫–ª—é—á–∞—î–º–æ—Å—å –¥–æ ${site.url}...`);
                    
                    const packet = document.createElement('div');
                    packet.className = 'vis-data-packet';
                    packet.innerHTML = 'üìÑ';
                    mainArea.appendChild(packet);
                    
                    const sourceRect = sourceElement.getBoundingClientRect();
                    const scraperRect = scraperContainer.getBoundingClientRect();
                    const storageRect = storageContainer.getBoundingClientRect();
                    const mainAreaRect = mainArea.getBoundingClientRect();

                    const startTop = sourceRect.top - mainAreaRect.top + (sourceRect.height / 2);
                    const startLeft = sourceRect.left - mainAreaRect.left + (sourceRect.width / 2);
                    const midTop = scraperRect.top - mainAreaRect.top + (scraperRect.height / 2);
                    const midLeft = scraperRect.left - mainAreaRect.left + (scraperRect.width / 2);
                    const endTop = storageRect.top - mainAreaRect.top + (storageRect.height / 2);
                    const endLeft = storageRect.left - mainAreaRect.left + (storageRect.width / 2);

                    packet.style.top = `${startTop}px`;
                    packet.style.left = `${startLeft}px`;
                    packet.style.transform = 'translate(-50%, -50%) scale(0.5)';

                    await wait(50);
                    if (!isVisRunning) { if (mainArea.contains(packet)) mainArea.removeChild(packet); break; }
                    
                    packet.style.transition = 'top 1s ease-in-out, left 1s ease-in-out, opacity 0.5s, transform 1s ease-in-out';
                    packet.style.opacity = 1;
                    packet.style.transform = 'translate(-50%, -50%) scale(1)';
                    packet.style.top = `${midTop}px`;
                    packet.style.left = `${midLeft}px`;
                    
                    addToVisLog(logArea, `–ó–±–∏—Ä–∞—î–º–æ –¥–∞–Ω—ñ...`);
                    await wait(1100);
                    if (!isVisRunning) { if (mainArea.contains(packet)) mainArea.removeChild(packet); break; }

                    packet.style.transition = 'top 0.8s ease-in, left 0.8s ease-in, opacity 0.8s ease-in, transform 0.8s ease-in';
                    packet.style.opacity = 0;
                    packet.style.transform = 'translate(-50%, -50%) scale(0.2)';
                    packet.style.top = `${endTop}px`;
                    packet.style.left = `${endLeft}px`;
                    
                    addToVisLog(logArea, `–ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∑—ñ–±—Ä–∞–Ω—ñ –¥–∞–Ω—ñ...`);
                    await wait(900);
                    if (mainArea.contains(packet)) mainArea.removeChild(packet);
                    if (!isVisRunning) break; 

                    sourceElement.classList.remove('active');
                    sourceElement.classList.add('done');
                    addToVisLog(logArea, `–ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑ ${site.url}.`);

                    await wait(500);
                    if (!isVisRunning) break;
                }

                if (!isVisRunning) break;

                // --- B. Conclude the cycle and fade out ---
                addToVisLog(logArea, "–ó–±—ñ—Ä –¥–∞–Ω–∏—Ö –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000); 
                
                if (!isVisRunning) break;

                visContainer.style.transition = 'opacity 0.5s ease-in-out';
                visContainer.style.opacity = 0;
                await wait(500);
                
                if (!isVisRunning) break;

                // --- C. Reset the state while invisible and fade back in ---
                const allSources = workingArea.querySelectorAll('.vis-source');
                allSources.forEach(s => {
                    s.classList.remove('done', 'active');
                    s.classList.add('pending');
                });
                logArea.innerHTML = '';

                visContainer.style.opacity = 1;
                await wait(500);
                visContainer.style.transition = '';
            }
        }
        // --- END: EDITED BY GEMINI ---

        // --- END: Added by Gemini (Visualization Functions) ---

        // --- START: Call Visualization on initial load ---
        startDataCollectionVisualization();
        // --- END: Call Visualization on initial load ---

        function startDrag(e) {
            isDragging = true;
            document.body.style.cursor = 'grabbing';

            // --- MODIFIED by Gemini: Store *dot index* not pixel value ---
            previousLevelIndex = currentLevelIndex; // Store the starting point

            // --- NEW: Store start positions ---
            startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

            // --- MODIFIED: Detect drag target ---
            if (e.target === handle) {
                dragMode = 'pending'; // Handle can go vertical or horizontal
            } else {
                dragMode = 'horizontal'; // Clicks on line/dots default to horizontal
            }
            // --- END MODIFIED ---

            // --- NEW: Reset all segments on drag start ---
            segments.forEach((seg, i) => {
                seg.classList.remove('active');
                seg.style.height = '0px';
                // Set top position so it can shrink from the correct place if needed
                seg.style.top = `${dotPositions[i]}px`;
            });
        }

        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            dragMode = 'none'; // --- NEW ---
            document.body.style.cursor = 'default';

            // --- ADDED ---
            handle.classList.remove('grabbing'); // Remove class to grow handle
            handle.classList.remove('flowing'); // --- ADDED: Ensure flowing is removed
            clearTimeout(flowTimer); // --- ADDED: Clear any pending timer

            // --- NEW: Hide all segments on drag end ---
            // This makes them animate their width back to 4px and then hide
            segments.forEach((seg, i) => {
                seg.classList.remove('active');
                // After a delay (for width animation), hide height
                // --- CHANGED: Faster timeout ---
                setTimeout(() => {
                    if (!isDragging) { // Only hide if we are still not dragging
                         seg.style.height = '0px';
                         seg.style.top = handle.style.top; // Shrink to handle
                    }
                }, 300); // 300ms matches width transition
            });
        }

        function onDrag(e) {
            if (!isDragging) return;

            // --- NEW: Get current X and Y ---
            const currentX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

            if (dragMode === 'pending') {
                const deltaX = currentX - startX;
                const deltaY = currentY - startY;

                // Check for dominant axis after 10px of movement
                if (Math.abs(deltaY) > 10) {
                    dragMode = 'vertical';
                } else if (Math.abs(deltaX) > 10) {
                    dragMode = 'horizontal';
                } else {
                    return; // Wait for more movement
                }
            }

            // --- NEW: Handle vertical drag ---
            if (dragMode === 'vertical') {
                e.preventDefault(); // Prevent page scroll ONLY on vertical drag

                const eventY = currentY; // Use the calculated currentY
                const scrollerRect = scroller.getBoundingClientRect();

                const mouseY = eventY - scrollerRect.top;

                // Find the closest dot position to snap to
                let closestDotY = dotPositions.reduce((prev, curr) => {
                    return (Math.abs(curr - mouseY) < Math.abs(prev - mouseY) ? curr : prev);
                });

                // Snap the handle to the closest dot
                handle.style.top = `${closestDotY}px`;

                // --- START: Update Text Logic ---
                // Find the index of the closest dot
                let closestIndex = dotPositions.indexOf(closestDotY);

                // Update the text based on the index
                if (closestIndex !== -1 && closestIndex !== currentLevelIndex) {

                    // --- START: Flow Animation Logic ---
                    handle.classList.add('grabbing'); // --- MOVED HERE ---
                    handle.classList.add('flowing'); // Add class to elongate blue dot
                    clearTimeout(flowTimer); // Clear any existing timer

                    // --- CHANGED: Timer now resets segments too ---
                    flowTimer = setTimeout(() => {
                        handle.classList.remove('flowing');
                        handle.classList.remove('grabbing');
                        // --- THIS IS THE FIX ---
                        // Deactivate all segments when the flow animation ends
                        segments.forEach(seg => seg.classList.remove('active'));
                    }, 400); // Matches the `top` transition duration
                    // --- END: Flow Animation Logic ---

                    // Determine direction (1 for down, -1 for up)
                    const direction = closestIndex > currentLevelIndex ? 1 : -1;
                    const transitionDelay = 200; // Must match CSS transition duration
                    const slideDistance = 15; // How many pixels to slide

                    // 1. Slide and fade out
                    titleEn.style.opacity = 0;
                    titleEn.style.transform = `translateY(${direction * slideDistance}px)`;
                    titleUa.style.opacity = 0;
                    titleUa.style.transform = `translateY(${direction * slideDistance}px)`;

                    // 2. Update current index
                    currentLevelIndex = closestIndex;

                    // --- START: NEW Segment Logic ---
                    // This logic now runs ONLY when the index changes

                    // --- MODIFIED by Gemini: Use *dot index* not pixel value ---
                    const startIdx = Math.min(previousLevelIndex, currentLevelIndex);
                    const endIdx = Math.max(previousLevelIndex, currentLevelIndex);
                    // --- END MODIFIED ---

                    // Loop through all 6 segments
                    for (let i = 0; i < segments.length; i++) {
                        const segment = segments[i];

                        // Check if this segment index (0-5) is in the active range
                        if (i >= startIdx && i < endIdx) {
                            // This segment is active. Set its position and height *instantly*.
                            segment.style.top = `${dotPositions[i]}px`;
                            segment.style.height = `${dotPositions[i+1] - dotPositions[i]}px`;
                            // Add 'active' class to animate its WIDTH
                            segment.classList.add('active');
                        } else {
                            // This segment is not active.
                            segment.style.height = '0px';
                            segment.classList.remove('active');
                        }
                    }
                    // --- END: NEW Segment Logic ---

                    // --- START: Added by Gemini (Visualization Trigger) ---
                    if (currentLevelIndex === 6) {
                        // We snapped TO the data collection level
                        startDataCollectionVisualization();
                    } else if (previousLevelIndex === 6) {
                        // We just LEFT the data collection level
                        clearDataCollectionVisualization();
                    }
                    // --- END: Added by Gemini (Visualization Trigger) ---


                    // --- ADDED: This is the fix for single-segment animation ---
                    // Update previousLevelIndex so the *next* move only animates from this point
                    previousLevelIndex = currentLevelIndex;
                    // --- END: FIX ---

                    // 3. Wait for fade out, then change text and position for fade-in
                    setTimeout(() => {
                        // Change text content
                        // This now correctly maps to the inverted levelData array
                        titleEn.textContent = levelData[currentLevelIndex].en;
                        titleUa.textContent = levelData[currentLevelIndex].ua;

                        // Temporarily disable transition to set the "from" position
                        titleEn.style.transition = 'none';
                        titleUa.style.transition = 'none';

                        // Set "from" position (opposite direction)
                        titleEn.style.transform = `translateY(${-direction * slideDistance}px)`;
                        titleUa.style.transform = `translateY(${-direction * slideDistance}px)`;

                        // Force the browser to apply the transform immediately
                        titleEn.offsetHeight; // This is a trick to trigger a browser reflow

                        // 4. Re-enable transitions and slide/fade in to final position
                        titleEn.style.transition = 'opacity 0.2s ease-in-out, transform 0.2s ease-in-out';
                        titleUa.style.transition = 'opacity 0.2s ease-in-out, transform 0.2s ease-in-out';

                        titleEn.style.opacity = 1;
                        titleEn.style.transform = 'translateY(0)';
                        titleUa.style.opacity = 1;
                        titleUa.style.transform = 'translateY(0)';

                    }, transitionDelay);
                }
                // --- END: Update Text Logic ---
            }
            // --- MODIFIED: Changed 'else if' to 'if' ---
            if (dragMode === 'horizontal') {
                e.preventDefault(); // Prevent horizontal page swipe
                const screenWidth = window.innerWidth;

                const isRightSide = topGroup.classList.contains('right');

                // --- START OF FIX: Set drag distance to (Half Screen - 10px) ---
                const dragDistance = currentX - startX; // Get horizontal drag distance
                const minDrag = (screenWidth / 2) - 10; // Min drag distance is (Half Screen - 10px)

                if (isRightSide && dragDistance < -minDrag) { // Dragged left
                    topGroup.classList.remove('right');
                    mainContentWrapper.classList.remove('right'); // Toggle wrapper class
                    endDrag(e); // Stop the drag immediately after toggle
                } else if (!isRightSide && dragDistance > minDrag) { // Dragged right
                    topGroup.classList.add('right');
                    mainContentWrapper.classList.add('right'); // Toggle wrapper class
                    endDrag(e); // Stop the drag immediately after toggle
                }
                // --- END OF FIX ---
            }
        }

        // --- START OF FIX: Replaced bad code with correct listeners ---
        // --- MODIFIED: Listeners moved to scroller ---
        // These listeners are on the 'scroller' container, which
        // is now back to 9px wide.
        scroller.addEventListener('mousedown', startDrag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', onDrag);

        // Touch events for mobile
        scroller.addEventListener('touchstart', startDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchmove', onDrag);
        // --- END: Scroller Logic ---
    });
</script>
</body>
</html>
