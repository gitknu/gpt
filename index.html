<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Як створити GPT</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- Updated to include font-weight 800 for extrabold -->
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;800&display=swap" rel="stylesheet">
<style>
    body, html {
        height: 100%;
        margin: 0;
        padding: 0;
        background-color: white;
        display: flex;
        flex-direction: column; /* Stack items vertically */
        font-family: sans-serif;
        box-sizing: border-box; /* Ensure padding/borders don't add to height */
    }

    .top-group {
        width: 100%;
        padding: 0 80px; /* --- EDITED: Increased horizontal padding --- */
        margin-top: 20px;
        box-sizing: border-box; /* Include padding in width */
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }


    /* New title style */
    .data-title-container {
        font-family: 'Montserrat', sans-serif;
        color: black;
        margin: 0;
        height: 86px; /* 1/7th of original 600px */
        display: flex;
        flex-direction: column;
        justify-content: center; /* Vertically center the text block */
        overflow: hidden; /* Added to clip the text during transition */
        user-select: none; /* ADDED: Prevent text selection on click */
        align-self: center; /* CHANGED: Center the title block */
        align-items: center; /* ADDED: Center the text lines inside */
    }

    .title-en {
        font-weight: 800; /* Extrabold */
        font-size: 2rem; /* 32px */
        line-height: 1.2;
        text-align: center; /* --- ADDED --- */
        color: #b80000;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    }

    .title-ua {
        font-weight: 800; /* Extrabold - CHANGED */
        font-size: 1.1rem; /* 17.6px - CHANGED (adjusted to match width with new weight) */
        line-height: 1.2;
        text-align: center;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    }

    .scroller-hint {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500; /* Not bold, as requested */
        font-size: 0.675rem; /* 75% of original 0.9rem */
        color: #cccccc; /* Barely visible grey color */
        margin-top: 8px; /* Space from title */
        margin-bottom: 0; /* No extra space, scroller has its own */
        align-self: center;
        text-align: center;
        user-select: none;
    }

    .scroller-hint .arrow-left {
        display: inline; /* Show left arrow by default (scroller is on the left) */
    }
    .scroller-hint .arrow-right {
        display: none; /* Hide right arrow by default */
    }

    .top-group.right .scroller-hint .arrow-left {
        display: none; /* Hide left arrow when scroller is on the right */
    }
    .top-group.right .scroller-hint .arrow-right {
        display: inline; /* Show right arrow when scroller is on the right */
    }

    .main-content-wrapper {
        flex-grow: 1; /* This wrapper fills the vertical space */
        width: 100%;
        box-sizing: border-box;
        margin: 10px 0 0 0;
        padding: 0 80px; /* --- EDITED: Increased horizontal padding --- */
        position: relative; /* CRITICAL: For absolute positioning child */
    }
/* --- END: EDITED BY GEMINI --- */


    /* --- START: Scroller Styles --- */
/* --- START: EDITED BY GEMINI --- */
    .scroller-container {
        margin-top: 0;
        height: 514px; /* 6/7ths of original 600px */
        width: 9px;
        background-color: transparent;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        position: absolute; /* CRITICAL: Now absolutely positioned */
        top: 0; /* Align to top of wrapper */
        left: 80px; /* --- EDITED: Matched new padding --- */
        transition: left 0.4s cubic-bezier(0.65, 0, 0.35, 1);
    }

    .scroller-container::before {
        content: '';
        position: absolute;
        width: 4px;
        height: 100%;
        background-color: black;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1;
    }

    .thick-segment {
        position: absolute;
        width: 4px; /* Start at thin width */
        background-color: black;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2; /* Above thin line */
        height: 0; /* Controlled by JS */
        top: 0; /* Controlled by JS */
        transition: width 0.3s cubic-bezier(0.65, 0, 0.35, 1);
    }

    .thick-segment.active {
        width: 9px; /* Animate to thick width */
    }

    .dot {
        width: 20px;
        height: 20px;
        background-color: black;
        border-radius: 50%;
        flex-shrink: 0;
        position: relative;
        z-index: 3; /* Above thick line */
    }

    #scroller-handle {
        width: 36px; /* This is the outer black dot */
        height: 36px;
        background-color: black;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        transform: translate(-50%, -50%) scale(1);
        cursor: grab;
        transition: top 0.4s cubic-bezier(0.65, 0, 0.35, 1),
                    transform 0.3s cubic-bezier(0.65, 0, 0.35, 1);
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 4; /* Topmost element */
    }

    #scroller-handle::before {
        content: '';
        display: block;
        width: 18px;
        height: 18px;
        background-color: #0b5394; /* The blue liquid */
        border-radius: 50%;
        transform: scale(1);
        transition: transform 0.3s cubic-bezier(0.65, 0, 0.35, 1);
    }

    #scroller-handle.grabbing {
        transform: translate(-50%, -50%) scaleX(0.25) scaleY(1);
        cursor: grabbing;
    }

    #scroller-handle.grabbing::before {
        transform: scaleX(2) scaleY(0.5);
    }

    /* --- ADDED: This is the "flowing" state --- */
    #scroller-handle.grabbing.flowing::before {
        transform: scaleX(2) scaleY(2.0);
    }

    #scroller-handle:active {
        cursor: grabbing;
    }

    .working-area {
        border: 2px dashed black;
        border-radius: 10px;
        /* CRITICAL: Set fixed margins on BOTH sides */
        margin-left: 24px;
        margin-right: 24px;
        /* ADDED: Set height to match scroller */
        height: 514px;
        box-sizing: border-box; /* Account for border */
    }

    .main-content-wrapper.right .scroller-container {
        left: calc(100% - 80px - 9px); /* --- EDITED: Matched new padding --- */
    }

    .logo-container {
        display: flex;
        flex-direction: row;
        align-items: flex-end;
        gap: 20px;
        margin-bottom: 20px;
        width: 100%;
        justify-content: center;
        margin-top: auto; /* Pushes logos to the bottom */
        box-sizing: border-box; /* --- ADDED: THIS IS THE FIX --- */
    }
/* --- END: EDITED BY GEMINI --- */

    .logo-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }

    .logo-label {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500;
        font-size: 16px;
        color: #333;
        margin-bottom: 10px; /* Space between text and logo */
    }

    .logo-link {
        display: inline-block;
    }

    .logo {
        width: 150px; /* Adjust size as needed */
        height: auto;
        transition: transform 0.2s ease-in-out;
    }

    .logo:hover {
        transform: scale(1.1);
    }

    /* --- Mobile Responsivity --- */
    @media (max-width: 600px) {

        /* Adjust top group for mobile */
        .top-group {
            padding: 0 40px; /* --- EDITED: Increased horizontal padding for mobile --- */
            margin-top: 10px;
        }

        /* Adjust title for mobile */
        .data-title-container {
            height: 57px; /* 1/7th of original 400px */
        }

        .title-en {
            font-size: 1.5rem; /* 24px */
        }

        .title-ua {
            font-size: 0.83rem; /* 13.28px - CHANGED (adjusted to match mobile width with new weight) */
        }

        /* --- ADDED: Mobile hint styles --- */
        .scroller-hint {
            font-size: 0.6rem; /* 75% of 0.8rem */
            margin-top: 4px;
        }

/* --- START: EDITED BY GEMINI --- */
        .main-content-wrapper {
            margin: 10px 0 0 0;
            padding: 0 40px; /* --- EDITED: Increased horizontal padding for mobile --- */
        }

        .scroller-container {
            margin-top: 0;
            height: 343px; /* 6/7ths of original 400px */
            left: 40px; /* --- EDITED: Matched new mobile padding --- */
        }

        /* CRITICAL: Mobile rule for scroller on the right */
        .main-content-wrapper.right .scroller-container {
            left: calc(100% - 40px - 9px); /* --- EDITED: Matched new mobile padding --- */
        }
/* --- END: EDITED BY GEMINI --- */

        .dot {
            width: 16px;
            height: 16px;
        }

        #scroller-handle {
            width: 24px;
            height: 24px;
        }

        #scroller-handle::before {
            width: 10px;
            height: 10px;
        }

/* --- START: EDITED BY GEMINI --- */
        /* --- ADDED: Mobile style for working area --- */
        .working-area {
            /* CRITICAL: Set fixed margins on BOTH sides for mobile */
            margin-left: 12px; /* Half of desktop */
            margin-right: 12px; /* Half of desktop */
            /* ADDED: Set height to match mobile scroller */
            height: 343px;
            box-sizing: border-box;
        }

        /* REMOVED: .main-content-wrapper.right .working-area rule */
/* --- END: EDITED BY GEMINI --- */


/* --- START: EDITED BY GEMINI --- */
        .logo-container {
            padding: 0 40px 20px; /* --- EDITED: Matched new mobile padding --- */
            margin-bottom: 0;
            gap: 15px;
            flex-wrap: wrap; /* --- ADDED: Prevents horizontal overflow --- */
            /* The box-sizing: border-box from the main rule fixes the width */
        }
/* --- END: EDITED BY GEMINI --- */
        .logo {
            width: 90px; /* Logos size on mobile */
        }
        .logo-label {
            font-size: 14px; /* Slightly smaller text on mobile */
        }
    }
</style>
</head>
<body>

<!-- Top content group -->
<div class="top-group">
    <!-- Updated title structure -->
    <div class="data-title-container">
        <!-- This text will be updated by the script -->
        <!-- Set initial text to Level 1 (which is now at the bottom) -->
        <span class="title-en">Data collection:</span>
        <span class="title-ua">процес збору даних</span>
    </div>

    <!-- --- MODIFIED: New hint text with spans for arrows --- -->
    <p class="scroller-hint">
        <i>
            <span class="arrow-left">↶</span>
            можна потягнути на інший бік екрану
            <span class="arrow-right">↷</span>
        </i>
    </p>
</div>

<!-- New wrapper for scroller and content -->
<div class="main-content-wrapper">
    <!-- Scroller is now here -->
    <!-- Its position is controlled by position:absolute -->
    <div class="scroller-container">
        <!-- ADDED: 6 segments for the 6 gaps between 7 dots -->
        <div class="thick-segment" id="segment-0"></div>
        <div class="thick-segment" id="segment-1"></div>
        <div class="thick-segment" id="segment-2"></div>
        <div class="thick-segment" id="segment-3"></div>
        <div class="thick-segment" id="segment-4"></div>
        <div class="thick-segment" id="segment-5"></div>

        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <!-- REMOVED: #thick-line-segment -->
        <div id="scroller-handle"></div>
    </div>

    <!-- Dashed box is now here -->
    <!-- Its position is fixed by its own margins -->
    <div class="working-area"></div>
</div>


<!-- Logo content is placed here, positioned at the bottom by the body's flex settings -->
<div class="logo-container">
    <div class="logo-item">
        <p class="logo-label">Комп'ютер</p>
        <a href="https://ollama.com" target="_blank" class="logo-link">
            <img src="https://gitknu.github.io/gpt/files/ollama.png" alt="Ollama Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=Ollama';">
        </a>
    </div>
    <div class="logo-item">
        <p class="logo-label">Смартфон</p>
        <a href="https://play.google.com/store/apps/details?id=com.pocketpalai" target="_blank" class="logo-link" id="pocketpal-link">
            <img src="https://gitknu.github.io/gpt/files/pocketpal.png" alt="PocketPal Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=PocketPal';">
        </a>
    </div>
    <div class="logo-item">
        <p class="logo-label">Власна АІ</p>
        <a href="https://github.com/theaniketgiri/create-llm" target="_blank" class="logo-link">
            <img src="https://gitknu.github.io/gpt/files/github.png" alt="GitHub Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=GitHub';">
        </a>
    </div>
</div>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        // --- START: PocketPal Link Logic ---
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const pocketpalLink = document.getElementById("pocketpal-link");

        // Check for iOS/iPadOS
        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            pocketpalLink.href = "https://apps.apple.com/us/app/pocketpal-ai/id6502579498";
        }
        // Check for MacOS
        else if (/Macintosh|MacIntel|MacPPC|Mac68K/.test(userAgent)) {
            pocketpalLink.href = "https://apps.apple.com/us/app/pocketpal-ai/id6502579498";
        }
        // --- END: PocketPal Link Logic ---

        const scrollerContainer = document.querySelector('.scroller-container');
        const mainContentWrapper = document.querySelector('.main-content-wrapper');
        const topGroup = document.querySelector('.top-group');


        // --- START: Text Data for Scroller (INVERTED) ---
        const levelData = [
            // Index 0 (Top Dot) is now Level 7
            { en: "RLHF:", ua: "навчання по відгуках" },
            { en: "Reward model training:", ua: "створення моделі винагороди" },
            { en: "Supervised finetuning:", ua: "донавчання (зі вчителем)" },
            { en: "Unsupervised pretraining:", ua: "попереднє навчання (без вчителя)" },
            { en: "Tokenization:", ua: "розбиття на токени" },
            { en: "Preprocessing:", ua: "попередня обробка" },
            // Index 6 (Bottom Dot) is now Level 1
            { en: "Data collection:", ua: "процес збору даних" }
        ];

        const titleEn = document.querySelector('.title-en');
        const titleUa = document.querySelector('.title-ua');
        // Set initial level index to 6 (Bottom dot, which is now Level 1)
        let currentLevelIndex = 6; // Keep track of the current level
        let previousLevelIndex = 6; // --- ADDED: Keep track of previous dot
        // --- END: Text Data for Scroller ---


        // --- START: Scroller Logic ---
        const handle = document.getElementById('scroller-handle');
        const scroller = handle.parentElement; // This is the scroller-container
        const dots = Array.from(scroller.getElementsByClassName('dot'));
        // --- ADDED: Get all segments ---
        const segments = Array.from(scroller.getElementsByClassName('thick-segment'));
        // --- REMOVED: thickLine ---
        let isDragging = false;
        let flowTimer; // --- ADDED: Timer for flow animation

        // --- NEW DRAG LOGIC VARS ---
        let startX = 0;
        let startY = 0;
        let dragMode = 'none'; // 'none', 'pending', 'vertical', 'horizontal'
        // --- END NEW VARS ---

        const dotPositions = dots.map(dot => dot.offsetTop + dot.offsetHeight / 2);

        // Set initial position of the handle to the *last* dot (bottom)
        handle.style.top = `${dotPositions[dotPositions.length - 1]}px`;

        function startDrag(e) {
            isDragging = true;
            document.body.style.cursor = 'grabbing';

            previousLevelIndex = currentLevelIndex; // Store the starting point

            // --- NEW: Store start positions ---
            startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

            // --- MODIFIED: Detect drag target ---
            if (e.target === handle) {
                dragMode = 'pending'; // Handle can go vertical or horizontal
            } else {
                dragMode = 'horizontal'; // Clicks on line/dots default to horizontal
            }
            // --- END MODIFIED ---

            // --- NEW: Reset all segments on drag start ---
            segments.forEach((seg, i) => {
                seg.classList.remove('active');
                seg.style.height = '0px';
                // Set top position so it can shrink from the correct place if needed
                seg.style.top = `${dotPositions[i]}px`;
            });
        }

        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            dragMode = 'none'; // --- NEW ---
            document.body.style.cursor = 'default';

            // --- ADDED ---
            handle.classList.remove('grabbing'); // Remove class to grow handle
            handle.classList.remove('flowing'); // --- ADDED: Ensure flowing is removed
            clearTimeout(flowTimer); // --- ADDED: Clear any pending timer

            // --- NEW: Hide all segments on drag end ---
            // This makes them animate their width back to 4px and then hide
            segments.forEach((seg, i) => {
                seg.classList.remove('active');
                // After a delay (for width animation), hide height
                // --- CHANGED: Faster timeout ---
                setTimeout(() => {
                    if (!isDragging) { // Only hide if we are still not dragging
                         seg.style.height = '0px';
                         seg.style.top = handle.style.top; // Shrink to handle
                    }
                }, 300); // 300ms matches width transition
            });
        }

        function onDrag(e) {
            if (!isDragging) return;

            // --- NEW: Get current X and Y ---
            const currentX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

            if (dragMode === 'pending') {
                const deltaX = currentX - startX;
                const deltaY = currentY - startY;

                // Check for dominant axis after 10px of movement
                if (Math.abs(deltaY) > 10) {
                    dragMode = 'vertical';
                } else if (Math.abs(deltaX) > 10) {
                    dragMode = 'horizontal';
                } else {
                    return; // Wait for more movement
                }
            }

            // --- NEW: Handle vertical drag ---
            if (dragMode === 'vertical') {
                e.preventDefault(); // Prevent page scroll ONLY on vertical drag

                const eventY = currentY; // Use the calculated currentY
                const scrollerRect = scroller.getBoundingClientRect();

                const mouseY = eventY - scrollerRect.top;

                // Find the closest dot position to snap to
                let closestDotY = dotPositions.reduce((prev, curr) => {
                    return (Math.abs(curr - mouseY) < Math.abs(prev - mouseY) ? curr : prev);
                });

                // Snap the handle to the closest dot
                handle.style.top = `${closestDotY}px`;

                // --- START: Update Text Logic ---
                // Find the index of the closest dot
                let closestIndex = dotPositions.indexOf(closestDotY);

                // Update the text based on the index
                if (closestIndex !== -1 && closestIndex !== currentLevelIndex) {

                    // --- START: Flow Animation Logic ---
                    handle.classList.add('grabbing'); // --- MOVED HERE ---
                    handle.classList.add('flowing'); // Add class to elongate blue dot
                    clearTimeout(flowTimer); // Clear any existing timer

                    // --- CHANGED: Timer now resets segments too ---
                    flowTimer = setTimeout(() => {
                        handle.classList.remove('flowing');
                        handle.classList.remove('grabbing');
                        // --- THIS IS THE FIX ---
                        // Deactivate all segments when the flow animation ends
                        segments.forEach(seg => seg.classList.remove('active'));
                    }, 400); // Matches the `top` transition duration
                    // --- END: Flow Animation Logic ---

                    // Determine direction (1 for down, -1 for up)
                    const direction = closestIndex > currentLevelIndex ? 1 : -1;
                    const transitionDelay = 200; // Must match CSS transition duration
                    const slideDistance = 15; // How many pixels to slide

                    // 1. Slide and fade out
                    titleEn.style.opacity = 0;
                    titleEn.style.transform = `translateY(${direction * slideDistance}px)`;
                    titleUa.style.opacity = 0;
                    titleUa.style.transform = `translateY(${direction * slideDistance}px)`;

                    // 2. Update current index
                    currentLevelIndex = closestIndex;

                    // --- START: NEW Segment Logic ---
                    // This logic now runs ONLY when the index changes

                    const startIdx = Math.min(previousLevelIndex, currentLevelIndex);
                    const endIdx = Math.max(previousLevelIndex, currentLevelIndex);

                    // Loop through all 6 segments
                    for (let i = 0; i < segments.length; i++) {
                        const segment = segments[i];

                        // Check if this segment index (0-5) is in the active range
                        if (i >= startIdx && i < endIdx) {
                            // This segment is active. Set its position and height *instantly*.
                            segment.style.top = `${dotPositions[i]}px`;
                            segment.style.height = `${dotPositions[i+1] - dotPositions[i]}px`;
                            // Add 'active' class to animate its WIDTH
                            segment.classList.add('active');
                        } else {
                            // This segment is not active.
                            segment.style.height = '0px';
                            segment.classList.remove('active');
                        }
                    }
                    // --- END: NEW Segment Logic ---

                    // --- ADDED: This is the fix for single-segment animation ---
                    // Update previousLevelIndex so the *next* move only animates from this point
                    previousLevelIndex = currentLevelIndex;
                    // --- END: FIX ---

                    // 3. Wait for fade out, then change text and position for fade-in
                    setTimeout(() => {
                        // Change text content
                        // This now correctly maps to the inverted levelData array
                        titleEn.textContent = levelData[currentLevelIndex].en;
                        titleUa.textContent = levelData[currentLevelIndex].ua;

                        // Temporarily disable transition to set the "from" position
                        titleEn.style.transition = 'none';
                        titleUa.style.transition = 'none';

                        // Set "from" position (opposite direction)
                        titleEn.style.transform = `translateY(${-direction * slideDistance}px)`;
                        titleUa.style.transform = `translateY(${-direction * slideDistance}px)`;

                        // Force the browser to apply the transform immediately
                        titleEn.offsetHeight; // This is a trick to trigger a browser reflow

                        // 4. Re-enable transitions and slide/fade in to final position
                        titleEn.style.transition = 'opacity 0.2s ease-in-out, transform 0.2s ease-in-out';
                        titleUa.style.transition = 'opacity 0.2s ease-in-out, transform 0.2s ease-in-out';

                        titleEn.style.opacity = 1;
                        titleEn.style.transform = 'translateY(0)';
                        titleUa.style.opacity = 1;
                        titleUa.style.transform = 'translateY(0)';

                    }, transitionDelay);
                }
                // --- END: Update Text Logic ---
            }
            // --- MODIFIED: Changed 'else if' to 'if' ---
            if (dragMode === 'horizontal') {
                e.preventDefault(); // Prevent horizontal page swipe
                const screenWidth = window.innerWidth;

                const isRightSide = topGroup.classList.contains('right');

                // --- START OF FIX: Set drag distance to (Half Screen - 10px) ---
                const dragDistance = currentX - startX; // Get horizontal drag distance
                const minDrag = (screenWidth / 2) - 10; // Min drag distance is (Half Screen - 10px)

                if (isRightSide && dragDistance < -minDrag) { // Dragged left
                    topGroup.classList.remove('right');
                    mainContentWrapper.classList.remove('right'); // Toggle wrapper class
                    endDrag(e); // Stop the drag immediately after toggle
                } else if (!isRightSide && dragDistance > minDrag) { // Dragged right
                    topGroup.classList.add('right');
                    mainContentWrapper.classList.add('right'); // Toggle wrapper class
                    endDrag(e); // Stop the drag immediately after toggle
                }
                // --- END OF FIX ---
            }
        }

        // --- START OF FIX: Replaced bad code with correct listeners ---
        // --- MODIFIED: Listeners moved to scroller ---
        // These listeners are on the 'scroller' container, which
        // is now back to 9px wide.
        scroller.addEventListener('mousedown', startDrag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', onDrag);

        // Touch events for mobile
        scroller.addEventListener('touchstart', startDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchmove', onDrag);
        // --- END: Scroller Logic ---
    });
</script>
</body>
</html>
