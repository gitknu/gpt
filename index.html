<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–Ø–∫ —Å—Ç–≤–æ—Ä–∏—Ç–∏ GPT</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- Updated to include font-weight 800 for extrabold -->
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;800&display=swap" rel="stylesheet">
<style>
    body, html {
        height: 100%;
        margin: 0;
        padding: 0;
        background-color: white;
        display: flex;
        flex-direction: column; /* Stack items vertically */
        font-family: sans-serif;
        box-sizing: border-box; /* Ensure padding/borders don't add to height */
    }

    .top-group {
        width: 100%;
        padding: 0 80px; /* --- EDITED: Increased horizontal padding --- */
        margin-top: 20px;
        box-sizing: border-box; /* Include padding in width */
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }


    /* New title style */
    .data-title-container {
        font-family: 'Montserrat', sans-serif;
        color: black;
        margin: 0;
        height: 86px; /* 1/7th of original 600px */
        display: flex;
        flex-direction: column;
        justify-content: center; /* Vertically center the text block */
        overflow: hidden; /* Added to clip the text during transition */
        user-select: none; /* ADDED: Prevent text selection on click */
        align-self: center; /* CHANGED: Center the title block */
        align-items: center; /* ADDED: Center the text lines inside */
    }

    .title-en {
        font-weight: 800; /* Extrabold */
        font-size: 2rem; /* 32px */
        line-height: 1.2;
        text-align: center; /* --- ADDED --- */
        color: #b80000;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    }

    .title-ua {
        font-weight: 800; /* Extrabold - CHANGED */
        font-size: 1.1rem; /* 17.6px - CHANGED (adjusted to match width with new weight) */
        line-height: 1.2;
        text-align: center;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    }

    .scroller-hint {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500; /* Not bold, as requested */
        font-size: 0.675rem; /* 75% of original 0.9rem */
        color: #cccccc; /* Barely visible grey color */
        margin-top: 8px; /* Space from title */
        margin-bottom: 0; /* No extra space, scroller has its own */
        align-self: center;
        text-align: center;
        user-select: none;
    }

    .scroller-hint .arrow-left {
        display: inline; /* Show left arrow by default (scroller is on the left) */
    }
    .scroller-hint .arrow-right {
        display: none; /* Hide right arrow by default */
    }

    .top-group.right .scroller-hint .arrow-left {
        display: none; /* Hide left arrow when scroller is on the right */
    }
    .top-group.right .scroller-hint .arrow-right {
        display: inline; /* Show right arrow when scroller is on the right */
    }

    .main-content-wrapper {
        flex-grow: 1; /* This wrapper fills the vertical space */
        width: 100%;
        box-sizing: border-box;
        margin: 10px 0 0 0;
        padding: 0 80px; /* --- EDITED: Increased horizontal padding --- */
        position: relative; /* CRITICAL: For absolute positioning child */
    }
/* --- END: EDITED BY GEMINI --- */


    /* --- START: Scroller Styles --- */
/* --- START: EDITED BY GEMINI --- */
    .scroller-container {
        margin-top: 0;
        height: 514px; /* 6/7ths of original 600px */
        width: 9px;
        background-color: transparent;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        position: absolute; /* CRITICAL: Now absolutely positioned */
        top: 0; /* Align to top of wrapper */
        left: 80px; /* --- EDITED: Matched new padding --- */
        transition: left 0.4s cubic-bezier(0.65, 0, 0.35, 1);
    }

    .scroller-container::before {
        content: '';
        position: absolute;
        width: 4px;
        height: 100%;
        background-color: black;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1;
    }

    .thick-segment {
        position: absolute;
        width: 4px; /* Start at thin width */
        background-color: black;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2; /* Above thin line */
        height: 0; /* Controlled by JS */
        top: 0; /* Controlled by JS */
        transition: width 0.3s cubic-bezier(0.65, 0, 0.35, 1);
    }

    .thick-segment.active {
        width: 9px; /* Animate to thick width */
    }

    .dot {
        width: 20px;
        height: 20px;
        background-color: black;
        border-radius: 50%;
        flex-shrink: 0;
        position: relative;
        z-index: 3; /* Above thick line */
    }

    #scroller-handle {
        width: 36px; /* This is the outer black dot */
        height: 36px;
        background-color: black;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        transform: translate(-50%, -50%) scale(1);
        cursor: grab;
        transition: top 0.4s cubic-bezier(0.65, 0, 0.35, 1),
                    transform 0.3s cubic-bezier(0.65, 0, 0.35, 1);
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 4; /* Topmost element */
    }

    #scroller-handle::before {
        content: '';
        display: block;
        width: 18px;
        height: 18px;
        background-color: #0b5394; /* The blue liquid */
        border-radius: 50%;
        transform: scale(1);
        transition: transform 0.3s cubic-bezier(0.65, 0, 0.35, 1);
    }

    #scroller-handle.grabbing {
        transform: translate(-50%, -50%) scaleX(0.25) scaleY(1);
        cursor: grabbing;
    }

    #scroller-handle.grabbing::before {
        transform: scaleX(2) scaleY(0.5);
    }

    /* --- ADDED: This is the "flowing" state --- */
    #scroller-handle.grabbing.flowing::before {
        transform: scaleX(2) scaleY(2.0);
    }

    #scroller-handle:active {
        cursor: grabbing;
    }

    .working-area {
        border: 2px dashed black;
        border-radius: 10px;
        /* CRITICAL: Set fixed margins on BOTH sides */
        margin-left: 24px;
        margin-right: 24px;
        /* ADDED: Set height to match scroller */
        height: 514px;
        box-sizing: border-box; /* Account for border */
        /* --- START: Added by Gemini for visualization --- */
        padding: 20px;
        font-family: 'Courier New', Courier, monospace;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Hide overflow from animations */
        /* --- END: Added by Gemini for visualization --- */
    }

    .main-content-wrapper.right .scroller-container {
        left: calc(100% - 80px - 9px); /* --- EDITED: Matched new padding --- */
    }

    .logo-container {
        display: flex;
        flex-direction: row;
        align-items: flex-end;
        gap: 20px;
        margin-bottom: 20px;
        width: 100%;
        justify-content: center;
        margin-top: auto; /* Pushes logos to the bottom */
        box-sizing: border-box;
        padding: 0 40px; /* --- ADDED: Give logos original padding --- */
    }
/* --- END: EDITED BY GEMINI --- */

    .logo-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }

    .logo-label {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500;
        font-size: 16px;
        color: #333;
        margin-bottom: 10px; /* Space between text and logo */
    }

    .logo-link {
        display: inline-block;
    }

    .logo {
        width: 150px; /* Adjust size as needed */
        height: auto;
        transition: transform 0.2s ease-in-out;
    }

    .logo:hover {
        transform: scale(1.1);
    }

    .vis-log {
        margin-top: 15px;
        height: 100px; /* Fixed height for log area */
        width: 100%;
        border-top: 1px solid #eee; /* A subtle separator instead of a full border */
        padding-top: 10px;
        overflow-y: auto;
        font-size: 0.85rem;
        font-family: 'Courier New', Courier, monospace;
        flex-shrink: 0; /* Prevent log from shrinking */
    }
    .vis-log-entry {
        margin-bottom: 5px;
    }

    /* --- START: Data Collection Visualization Styles --- */
    .data-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: 'Montserrat', sans-serif;
        color: black;
    }
    .vis-main-area {
        width: 100%;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        position: relative;
        min-height: 0;
    }
    .vis-sources-row {
        display: flex;
        justify-content: center;
        gap: 30px;
        width: 100%;
    }
    .vis-source {
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: transform 0.3s, opacity 0.3s;
    }
    .vis-source-icon { font-size: 2.5rem; }
    .vis-source-url {
        font-size: 0.7rem;
        margin-top: 5px;
        font-family: 'Courier New', Courier, monospace;
    }
    .vis-source.pending { opacity: 0.4; }
    .vis-source.active {
        transform: scale(1.1);
        font-weight: bold;
    }
    .vis-source.done { opacity: 0.2; }
    .vis-scraper-icon {
        font-size: 4rem;
        animation: gentle-bob 2s infinite ease-in-out;
    }
    @keyframes gentle-bob {
        0% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0); }
    }
    .vis-storage-icon { font-size: 3.5rem; }
    .vis-data-packet {
        position: absolute;
        font-size: 2rem;
        opacity: 0;
        z-index: 10;
    }
    /* --- END: Data Collection Visualization Styles --- */

    /* --- START: Preprocessing Visualization Styles (Added by Gemini) --- */
    .preprocessing-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between; /* CHANGED for storage icon */
        font-family: 'Montserrat', sans-serif;
        color: black;
        position: relative; /* ADDED for packet positioning */
    }
    .vis-text-area {
        font-family: 'Times New Roman', Times, serif;
        font-size: 1.2rem; /* Adjusted for more text */
        line-height: 1.6;
        padding: 20px;
        text-align: justify;
        border: 1px solid #eee;
        border-radius: 5px;
        width: 100%;
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 150px; /* Ensure space for text */
    }
    .error-highlight {
        background-color: #ffdddd;
        border-radius: 3px;
        transition: all 0.3s ease-in-out;
    }
    .error-fixing {
        background-color: #ddffdd;
        text-decoration: line-through;
        opacity: 0.5;
    }
    .corrected-text {
        background-color: #ddffdd;
        font-weight: bold;
        transition: all 0.3s ease-in-out;
    }
    .vis-file-packet {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 2rem;
        opacity: 0;
        z-index: 10;
        transition: top 1s ease-in-out, left 1s ease-in-out, opacity 0.5s, transform 1s ease-in-out;
    }
    .vis-file-packet-name {
        font-size: 0.7rem;
        margin-top: 5px;
        font-family: 'Courier New', Courier, monospace;
        background-color: white;
        padding: 2px 4px;
        border-radius: 3px;
        border: 1px solid #ccc;
        transition: background-color 0.3s ease-in-out;
    }
    /* --- END: Preprocessing Visualization Styles --- */

    /* --- START: Tokenization Visualization Styles --- */
    .tokenization-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        font-family: 'Montserrat', sans-serif;
        color: black;
    }
    .vis-token-main {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;
    }
    .vis-sentence-area {
        font-size: 1.5rem;
        font-family: 'Courier New', Courier, monospace;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        min-height: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        width: 90%;
    }
    .vis-word-token {
        display: inline-block;
        padding: 5px;
        margin: 0;
        border-radius: 4px;
        transition: all 0.5s ease-in-out;
    }
    .vis-word-token.highlight {
        background-color: #f0e68c; /* Khaki */
        transform: scale(1.1);
    }
    .vis-word-token.spacing {
        margin: 0 10px;
    }
    .vis-vocab-area {
        width: 90%;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        min-height: 80px;
        border: 1px dashed #aaa;
        padding: 10px;
        border-radius: 5px;
    }
    .vis-vocab-entry {
        background-color: #e0e0e0;
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 0.9rem;
        opacity: 0;
        transform: scale(0.5);
        transition: all 0.5s ease-in-out;
    }
    .vis-vocab-entry.visible {
        opacity: 1;
        transform: scale(1);
    }
     .vis-vocab-entry.highlight {
        background-color: #add8e6; /* Light Blue */
        box-shadow: 0 0 10px #add8e6;
    }
    .vis-vocab-id {
        font-weight: bold;
        color: #b80000;
        margin-right: 8px;
    }
    .vis-sequence-area {
        font-size: 1.5rem;
        font-family: 'Courier New', Courier, monospace;
        letter-spacing: 5px;
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 15px;
        min-height: 50px;
        width: 90%;
        text-align: center;
    }
    /* --- END: Tokenization Visualization Styles --- */


    /* --- Mobile Responsivity --- */
    @media (max-width: 600px) {

        /* Adjust top group for mobile */
        .top-group {
            padding: 0 40px; /* --- EDITED: Increased horizontal padding for mobile --- */
            margin-top: 10px;
        }

        /* Adjust title for mobile */
        .data-title-container {
            height: 57px; /* 1/7th of original 400px */
        }

        .title-en {
            font-size: 1.5rem; /* 24px */
        }

        .title-ua {
            font-size: 0.83rem; /* 13.28px - CHANGED (adjusted to match mobile width with new weight) */
        }

        /* --- ADDED: Mobile hint styles --- */
        .scroller-hint {
            font-size: 0.6rem; /* 75% of 0.8rem */
            margin-top: 4px;
        }

/* --- START: EDITED BY GEMINI --- */
        .main-content-wrapper {
            margin: 10px 0 0 0;
            padding: 0 40px; /* --- EDITED: Increased horizontal padding for mobile --- */
        }

        .scroller-container {
            margin-top: 0;
            height: 343px; /* 6/7ths of original 400px */
            left: 40px; /* --- EDITED: Matched new mobile padding --- */
        }

        /* CRITICAL: Mobile rule for scroller on the right */
        .main-content-wrapper.right .scroller-container {
            left: calc(100% - 40px - 9px); /* --- EDITED: Matched new mobile padding --- */
        }
/* --- END: EDITED BY GEMINI --- */

        .dot {
            width: 16px;
            height: 16px;
        }

        #scroller-handle {
            width: 24px;
            height: 24px;
        }

        #scroller-handle::before {
            width: 10px;
            height: 10px;
        }

/* --- START: EDITED BY GEMINI --- */
        /* --- ADDED: Mobile style for working area --- */
        .working-area {
            /* CRITICAL: Set fixed margins on BOTH sides for mobile */
            margin-left: 12px; /* Half of desktop */
            margin-right: 12px; /* Half of desktop */
            /* ADDED: Set height to match mobile scroller */
            height: 343px;
            box-sizing: border-box;
            /* --- START: Added by Gemini for visualization (mobile) --- */
            padding: 10px;
            font-size: 0.8rem;
            /* --- END: Added by Gemini for visualization (mobile) --- */
        }
        
        /* Data collection mobile styles */
        .vis-sources-row { gap: 15px; }
        .vis-source-icon { font-size: 2rem; }
        .vis-source-url { font-size: 0.6rem; }
        .vis-scraper-icon { font-size: 3rem; }
        .vis-storage-icon { font-size: 3rem; }
        
        .vis-log {
            height: 60px;
            font-size: 0.75rem;
            margin-top: 10px;
        }

        /* Preprocessing mobile styles (Added by Gemini) */
        .vis-text-area {
            font-size: 0.9rem; /* Adjusted */
            line-height: 1.5;
            padding: 10px;
            min-height: 100px;
        }
        
        /* Tokenization mobile styles */
        .vis-sentence-area { font-size: 1rem; min-height: 40px; }
        .vis-word-token.spacing { margin: 0 2px; }
        .vis-vocab-area { min-height: 60px; gap: 5px; }
        .vis-vocab-entry { font-size: 0.75rem; padding: 3px 8px; }
        .vis-sequence-area { font-size: 1rem; padding: 10px; min-height: 40px; }


/* --- END: EDITED BY GEMINI --- */


/* --- START: EDITED BY GEMINI --- */
        .logo-container {
            padding: 0 20px 20px; /* --- EDITED: Reverted to original mobile padding --- */
            margin-bottom: 0;
            gap: 15px;
            flex-wrap: wrap; /* --- ADDED: Prevents horizontal overflow --- */
        }
/* --- END: EDITED BY GEMINI --- */
        .logo {
            width: 90px; /* Logos size on mobile */
        }
        .logo-label {
            font-size: 14px; /* Slightly smaller text on mobile */
        }
    }
</style>
</head>
<body>

<!-- Top content group -->
<div class="top-group">
    <!-- Updated title structure -->
    <div class="data-title-container">
        <!-- This text will be updated by the script -->
        <!-- Set initial text to Level 1 (which is now at the bottom) -->
        <span class="title-en">Data collection:</span>
        <span class="title-ua">–ø—Ä–æ—Ü–µ—Å –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö</span>
    </div>

    <!-- --- MODIFIED: New hint text with spans for arrows --- -->
    <p class="scroller-hint">
        <i>
            <span class="arrow-left">‚Ü∂</span>
            –º–æ–∂–Ω–∞ –ø–æ—Ç—è–≥–Ω—É—Ç–∏ –Ω–∞ —ñ–Ω—à–∏–π –±—ñ–∫ –µ–∫—Ä–∞–Ω—É
            <span class="arrow-right">‚Ü∑</span>
        </i>
    </p>
</div>

<!-- New wrapper for scroller and content -->
<div class="main-content-wrapper">
    <!-- Scroller is now here -->
    <!-- Its position is controlled by position:absolute -->
    <div class="scroller-container">
        <!-- ADDED: 6 segments for the 6 gaps between 7 dots -->
        <div class="thick-segment" id="segment-0"></div>
        <div class="thick-segment" id="segment-1"></div>
        <div class="thick-segment" id="segment-2"></div>
        <div class="thick-segment" id="segment-3"></div>
        <div class="thick-segment" id="segment-4"></div>
        <div class="thick-segment" id="segment-5"></div>

        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <!-- REMOVED: #thick-line-segment -->
        <div id="scroller-handle"></div>
    </div>

    <!-- Dashed box is now here -->
    <!-- Its position is fixed by its own margins -->
    <div class="working-area"></div>
</div>


<!-- Logo content is placed here, positioned at the bottom by the body's flex settings -->
<div class="logo-container">
    <div class="logo-item">
        <p class="logo-label">–ö–æ–º–ø'—é—Ç–µ—Ä</p>
        <a href="https://ollama.com" target="_blank" class="logo-link">
            <img src="https://gitknu.github.io/gpt/files/ollama.png" alt="Ollama Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=Ollama';">
        </a>
    </div>
    <div class="logo-item">
        <p class="logo-label">–°–º–∞—Ä—Ç—Ñ–æ–Ω</p>
        <a href="https://play.google.com/store/apps/details?id=com.pocketpalai" target="_blank" class="logo-link" id="pocketpal-link">
            <img src="https://gitknu.github.io/gpt/files/pocketpal.png" alt="PocketPal Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=PocketPal';">
        </a>
    </div>
    <div class="logo-item">
        <p class="logo-label">–í–ª–∞—Å–Ω–∞ –ê–Ü</p>
        <a href="https://github.com/theaniketgiri/create-llm" target="_blank" class="logo-link">
            <img src="https://gitknu.github.io/gpt/files/github.png" alt="GitHub Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=GitHub';">
        </a>
    </div>
</div>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        // --- START: PocketPal Link Logic ---
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const pocketpalLink = document.getElementById("pocketpal-link");

        // Check for iOS/iPadOS
        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            pocketpalLink.href = "https://apps.apple.com/us/app/pocketpal-ai/id6502579498";
        }
        // Check for MacOS
        else if (/Macintosh|MacIntel|MacPPC|Mac68K/.test(userAgent)) {
            pocketpalLink.href = "https://apps.apple.com/us/app/pocketpal-ai/id6502579498";
        }
        // --- END: PocketPal Link Logic ---

        const scrollerContainer = document.querySelector('.scroller-container');
        const mainContentWrapper = document.querySelector('.main-content-wrapper');
        const topGroup = document.querySelector('.top-group');


        // --- START: Text Data for Scroller (INVERTED) ---
        const levelData = [
            // Index 0 (Top Dot) is now Level 7
            { en: "RLHF:", ua: "–Ω–∞–≤—á–∞–Ω–Ω—è –ø–æ –≤—ñ–¥–≥—É–∫–∞—Ö" },
            { en: "Reward model training:", ua: "—Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏" },
            { en: "Supervised finetuning:", ua: "–¥–æ–Ω–∞–≤—á–∞–Ω–Ω—è (–∑—ñ –≤—á–∏—Ç–µ–ª–µ–º)" },
            { en: "Unsupervised pretraining:", ua: "–ø–æ–ø–µ—Ä–µ–¥–Ω—î –Ω–∞–≤—á–∞–Ω–Ω—è (–±–µ–∑ –≤—á–∏—Ç–µ–ª—è)" },
            { en: "Tokenization:", ua: "—Ä–æ–∑–±–∏—Ç—Ç—è –Ω–∞ —Ç–æ–∫–µ–Ω–∏" },
            { en: "Preprocessing:", ua: "–ø–æ–ø–µ—Ä–µ–¥–Ω—è –æ–±—Ä–æ–±–∫–∞" },
            // Index 6 (Bottom Dot) is now Level 1
            { en: "Data collection:", ua: "–ø—Ä–æ—Ü–µ—Å –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö" }
        ];

        const titleEn = document.querySelector('.title-en');
        const titleUa = document.querySelector('.title-ua');
        // Set initial level index to 6 (Bottom dot, which is now Level 1)
        let currentLevelIndex = 6; // Keep track of the current level
        let previousLevelIndex = 6; // --- ADDED: Keep track of previous dot
        // --- END: Text Data for Scroller ---


        // --- START: Scroller Logic ---
        const handle = document.getElementById('scroller-handle');
        const scroller = handle.parentElement; // This is the scroller-container
        const dots = Array.from(scroller.getElementsByClassName('dot'));
        // --- ADDED: Get all segments ---
        const segments = Array.from(scroller.getElementsByClassName('thick-segment'));
        // --- REMOVED: thickLine ---
        let isDragging = false;
        let flowTimer; // --- ADDED: Timer for flow animation

        // --- NEW DRAG LOGIC VARS ---
        let startX = 0;
        let startY = 0;
        let dragMode = 'none'; // 'none', 'pending', 'vertical', 'horizontal'
        // --- END NEW VARS ---

        const dotPositions = dots.map(dot => dot.offsetTop + dot.offsetHeight / 2);

        // --- START: Added by Gemini (Visualization Vars) ---
        let isVisRunning = false;
        const workingArea = document.querySelector('.working-area');
        // --- END: Added by Gemini ---


        // Set initial position of the handle to the *last* dot (bottom)
        handle.style.top = `${dotPositions[dotPositions.length - 1]}px`;

        // --- START: Visualization Functions ---
        
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function addToVisLog(logArea, message) {
            if (!logArea) return;
            const entry = document.createElement('div');
            entry.className = 'vis-log-entry';
            entry.textContent = `> ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function clearVisualization() {
            workingArea.innerHTML = '';
            isVisRunning = false;
        }

        // --- Data Collection Visualizer ---
        async function startDataCollectionVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const sitesToScrape = [
                { id: "site-1", url: "news.com" },
                { id: "site-2", url: "reviews.com" },
                { id: "site-3", url: "blog.org" },
                { id: "site-4", url: "shop.net" }
            ];

            workingArea.innerHTML = `
                <div class="data-vis-container">
                    <div class="vis-main-area" id="vis-main-area">
                        <div class="vis-sources-row">
                            ${sitesToScrape.map(site => `
                                <div class="vis-source pending" id="${site.id}">
                                    <div class="vis-source-icon">üåê</div>
                                    <div class="vis-source-url">${site.url}</div>
                                </div>`).join('')}
                        </div>
                        <div id="vis-scraper-container"><div class="vis-scraper-icon">üï∑Ô∏è</div></div>
                        <div id="vis-storage-container"><div class="vis-storage-icon">üóÑÔ∏è</div></div>
                    </div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;

            const logArea = document.getElementById('vis-log');
            const mainArea = document.getElementById('vis-main-area');
            const scraperContainer = document.getElementById('vis-scraper-container');
            const storageContainer = document.getElementById('vis-storage-container');
            const visContainer = workingArea.querySelector('.data-vis-container');
            
            while (isVisRunning) {
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ –∑–∞–¥–∞—á—É –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö...");
                await wait(1000);

                for (const site of sitesToScrape) {
                    if (!isVisRunning) break; 

                    const sourceElement = document.getElementById(site.id);
                    sourceElement.classList.remove('pending');
                    sourceElement.classList.add('active');
                    addToVisLog(logArea, `–ü—ñ–¥–∫–ª—é—á–∞—î–º–æ—Å—å –¥–æ ${site.url}...`);
                    
                    const packet = document.createElement('div');
                    packet.className = 'vis-data-packet';
                    packet.innerHTML = 'üìÑ';
                    mainArea.appendChild(packet);
                    
                    const sourceRect = sourceElement.getBoundingClientRect();
                    const scraperRect = scraperContainer.getBoundingClientRect();
                    const storageRect = storageContainer.getBoundingClientRect();
                    const mainAreaRect = mainArea.getBoundingClientRect();
                    const startTop = sourceRect.top - mainAreaRect.top + (sourceRect.height / 2);
                    const startLeft = sourceRect.left - mainAreaRect.left + (sourceRect.width / 2);
                    const midTop = scraperRect.top - mainAreaRect.top + (scraperRect.height / 2);
                    const midLeft = scraperRect.left - mainAreaRect.left + (scraperRect.width / 2);
                    const endTop = storageRect.top - mainAreaRect.top + (storageRect.height / 2);
                    const endLeft = storageRect.left - mainAreaRect.left + (storageRect.width / 2);
                    packet.style.top = `${startTop}px`;
                    packet.style.left = `${startLeft}px`;
                    packet.style.transform = 'translate(-50%, -50%) scale(0.5)';
                    await wait(50);
                    if (!isVisRunning) { if (mainArea.contains(packet)) mainArea.removeChild(packet); break; }
                    packet.style.transition = 'top 1s ease-in-out, left 1s ease-in-out, opacity 0.5s, transform 1s ease-in-out';
                    packet.style.opacity = 1;
                    packet.style.transform = 'translate(-50%, -50%) scale(1)';
                    packet.style.top = `${midTop}px`;
                    packet.style.left = `${midLeft}px`;
                    addToVisLog(logArea, `–ó–±–∏—Ä–∞—î–º–æ –¥–∞–Ω—ñ...`);
                    await wait(1100);
                    if (!isVisRunning) { if (mainArea.contains(packet)) mainArea.removeChild(packet); break; }
                    packet.style.transition = 'top 0.8s ease-in, left 0.8s ease-in, opacity 0.8s ease-in, transform 0.8s ease-in';
                    packet.style.opacity = 0;
                    packet.style.transform = 'translate(-50%, -50%) scale(0.2)';
                    packet.style.top = `${endTop}px`;
                    packet.style.left = `${endLeft}px`;
                    addToVisLog(logArea, `–ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∑—ñ–±—Ä–∞–Ω—ñ –¥–∞–Ω—ñ...`);
                    await wait(900);
                    if (mainArea.contains(packet)) mainArea.removeChild(packet);
                    if (!isVisRunning) break; 
                    sourceElement.classList.remove('active');
                    sourceElement.classList.add('done');
                    addToVisLog(logArea, `–ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑ ${site.url}.`);
                    await wait(500);
                    if (!isVisRunning) break;
                }
                if (!isVisRunning) break;
                addToVisLog(logArea, "–ó–±—ñ—Ä –¥–∞–Ω–∏—Ö –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000); 
                if (!isVisRunning) break;
                visContainer.style.transition = 'opacity 0.5s ease-in-out';
                visContainer.style.opacity = 0;
                await wait(500);
                if (!isVisRunning) break;
                const allSources = workingArea.querySelectorAll('.vis-source');
                allSources.forEach(s => { s.classList.remove('done', 'active'); s.classList.add('pending'); });
                logArea.innerHTML = '';
                visContainer.style.opacity = 1;
                await wait(500);
                visContainer.style.transition = '';
            }
        }
        
        // --- Preprocessing Visualizer (EDITED BY GEMINI) ---
        async function startPreprocessingVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const processingJobs = [
                {
                    originalFilename: "article.docx",
                    finalFilename: "data_01.txt",
                    initialText: "–û—Å—å –ø—Ä–∏–∫–ª–∞–¥ —Ç–µ–∫—Å—Ç—É,–∑ –ø–æ–º–∏–ª–∫–∞–º–∏.. –º–∏ –±—É–¥–µ–º–æ –≤–∏–ø—Ä–∞–≤–ª—è—Ç–∏ —ó—Ö ,—â–æ–± –ø–æ–∫–∞–∑–∞—Ç–∏ –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥.",
                    fixes: [
                        { find: "—Ç–µ–∫—Å—Ç—É,–∑", replace: "—Ç–µ–∫—Å—Ç—É, –∑", log: "–î–æ–¥–∞—î–º–æ –ø—Ä–æ–±—ñ–ª –ø—ñ—Å–ª—è –∫–æ–º–∏..." },
                        { find: "..", replace: ".", log: "–í–∏–¥–∞–ª—è—î–º–æ –¥—É–±–ª—é—é—á—É –∫—Ä–∞–ø–∫—É..." },
                        { find: "—ó—Ö ,—â–æ–±", replace: "—ó—Ö, —â–æ–±", log: "–í–∏–ø—Ä–∞–≤–ª—è—î–º–æ –ø—Ä–æ–±—ñ–ª –ø–µ—Ä–µ–¥ –∫–æ–º–æ—é..." }
                    ]
                },
                {
                    originalFilename: "unformatted_data",
                    finalFilename: "data_02.txt",
                    initialText: "   –¢—É—Ç –±–∞–≥–∞—Ç–æ –∑–∞–π–≤–∏—Ö –ø—Ä–æ–±—ñ–ª—ñ–≤ —ñ –í–ï–õ–ò–ö–ò–• –ª—ñ—Ç–µ—Ä. –í—Å–µ —Ü–µ —Ç—Ä–µ–±–∞ –≤–∏–ø—Ä–∞–≤–∏—Ç–∏  .",
                    fixes: [
                        { find: "   ", replace: " ", log: "–í–∏–¥–∞–ª—è—î–º–æ –∑–∞–π–≤—ñ –ø—Ä–æ–±—ñ–ª–∏ –Ω–∞ –ø–æ—á–∞—Ç–∫—É..." },
                        { find: "–í–ï–õ–ò–ö–ò–•", replace: "–≤–µ–ª–∏–∫–∏—Ö", log: "–ü—Ä–∏–≤–æ–¥–∏–º–æ —Ç–µ–∫—Å—Ç –¥–æ –Ω–∏–∂–Ω—å–æ–≥–æ —Ä–µ–≥—ñ—Å—Ç—Ä—É..." },
                        { find: "  .", replace: ".", log: "–í–∏–¥–∞–ª—è—î–º–æ –∑–∞–π–≤—ñ –ø—Ä–æ–±—ñ–ª–∏ –≤ –∫—ñ–Ω—Ü—ñ..." }
                    ]
                },
                {
                    originalFilename: "reviews.json",
                    finalFilename: "data_03.txt",
                    initialText: "–¶–µ —Ç–µ–∫—Å—Ç –∑ HTML —Ç–µ–≥–∞–º–∏ <b>–∂–∏—Ä–Ω–∏–π</b> —Ç–∞ <i>–∫—É—Ä—Å–∏–≤</i>. –ü–æ—Ç—Ä—ñ–±–Ω–æ —ó—Ö –≤–∏–¥–∞–ª–∏—Ç–∏.",
                    fixes: [
                        { find: /<b>(.*?)<\/b>/g, replace: "$1", log: "–í–∏–¥–∞–ª—è—î–º–æ —Ç–µ–≥ <b>..." },
                        { find: /<i>(.*?)<\/i>/g, replace: "$1", log: "–í–∏–¥–∞–ª—è—î–º–æ —Ç–µ–≥ <i>..." }
                    ]
                }
            ];

            workingArea.innerHTML = `
                <div class="preprocessing-vis-container" id="preprocessing-vis-container">
                    <div class="vis-text-area" id="vis-text-area"></div>
                    <div id="vis-storage-container"><div class="vis-storage-icon">üóÑÔ∏è</div></div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;
            
            const logArea = document.getElementById('vis-log');
            const textArea = document.getElementById('vis-text-area');
            const visContainer = document.getElementById('preprocessing-vis-container');
            const storageContainer = document.getElementById('vis-storage-container');

            while (isVisRunning) {
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ –ø—Ä–æ—Ü–µ—Å –æ—á–∏—â–µ–Ω–Ω—è —Ç–∞ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Ñ–∞–π–ª—ñ–≤...");
                await wait(1500);
                if (!isVisRunning) break;

                for (const job of processingJobs) {
                    if (!isVisRunning) break;

                    textArea.innerHTML = `<span>${job.initialText}</span>`;
                    textArea.style.transition = 'opacity 0.3s';
                    textArea.style.opacity = 1;
                    addToVisLog(logArea, `–û–±—Ä–æ–±–∫–∞ —Ñ–∞–π–ª—É: ${job.originalFilename}`);
                    await wait(1000);
                    if (!isVisRunning) break;

                    for (const fix of job.fixes) {
                        if (!isVisRunning) break;
                        
                        addToVisLog(logArea, fix.log);
                        
                        // Highlight the error
                        let highlightedHtml = textArea.innerHTML.replace(fix.find, `<span class="error-highlight">${typeof fix.find === 'string' ? fix.find : fix.find.source}</span>`);
                        if (textArea.innerHTML !== highlightedHtml) {
                           textArea.innerHTML = highlightedHtml;
                        }
                        await wait(1000);
                        if (!isVisRunning) break;

                        // Animate the fix
                        const errorSpan = textArea.querySelector('.error-highlight');
                        if (errorSpan) {
                            errorSpan.classList.add('error-fixing');
                            errorSpan.classList.remove('error-highlight');
                        }
                        await wait(500);
                        if (!isVisRunning) break;

                        // Apply the fix
                        let fixedHtml = textArea.innerHTML.replace(/<span class="error-fixing">.*?<\/span>/, `<span class="corrected-text">${fix.replace}</span>`);
                        if(typeof fix.find !== 'string') { // Regex fix
                           fixedHtml = textArea.innerHTML.replace(/<span class="error-highlight">.*?<\/span>/, `<span class="corrected-text">${fix.replace}</span>`);
                           textArea.innerHTML = `<span>${textArea.textContent.replace(fix.find, fix.replace)}</span>`;
                        } else {
                           textArea.innerHTML = fixedHtml;
                        }

                        await wait(1000);
                        if (!isVisRunning) break;
                        
                        // Normalize the text (remove the corrected span)
                        textArea.innerHTML = `<span>${textArea.textContent}</span>`;
                        await wait(500);
                        if (!isVisRunning) break;
                    }
                    if (!isVisRunning) break;

                    addToVisLog(logArea, "–û—á–∏—â–µ–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ñ–∞–π–ª...");
                    textArea.style.opacity = 0.3;
                    await wait(500);
                    if (!isVisRunning) break;
                    
                    // File animation
                    const packet = document.createElement('div');
                    packet.className = 'vis-file-packet';
                    packet.innerHTML = `üìÑ<div class="vis-file-packet-name">${job.originalFilename}</div>`;
                    visContainer.appendChild(packet);

                    const textRect = textArea.getBoundingClientRect();
                    const storageRect = storageContainer.getBoundingClientRect();
                    const containerRect = visContainer.getBoundingClientRect();

                    const startTop = textRect.top - containerRect.top + (textRect.height / 2);
                    const startLeft = textRect.left - containerRect.left + (textRect.width / 2);
                    const endTop = storageRect.top - containerRect.top + (storageRect.height / 2);
                    const endLeft = storageRect.left - containerRect.left + (storageRect.width / 2);

                    packet.style.top = `${startTop}px`;
                    packet.style.left = `${startLeft}px`;
                    packet.style.transform = 'translate(-50%, -50%) scale(0.5)';

                    await wait(50);
                    if (!isVisRunning) { if (visContainer.contains(packet)) visContainer.removeChild(packet); break; }
                    
                    packet.style.opacity = 1;
                    packet.style.transform = 'translate(-50%, -50%) scale(1)';
                    packet.style.top = `${endTop}px`;
                    packet.style.left = `${endLeft}px`;

                    await wait(1100);
                    if (!isVisRunning) { if (visContainer.contains(packet)) visContainer.removeChild(packet); break; }

                    addToVisLog(logArea, `–ü–µ—Ä–µ–π–º–µ–Ω–æ–≤—É—î–º–æ –≤ ${job.finalFilename}`);
                    const nameTag = packet.querySelector('.vis-file-packet-name');
                    nameTag.style.backgroundColor = '#ddffdd';
                    nameTag.textContent = job.finalFilename;
                    
                    await wait(1000);
                    if (!isVisRunning) { if (visContainer.contains(packet)) visContainer.removeChild(packet); break; }
                    
                    packet.style.opacity = 0;
                    await wait(500);
                    if (visContainer.contains(packet)) visContainer.removeChild(packet);
                    if (!isVisRunning) break;

                    textArea.innerHTML = '';
                    await wait(500);
                    if (!isVisRunning) break;
                }

                if (!isVisRunning) break;
                addToVisLog(logArea, "–í—Å—ñ —Ñ–∞–π–ª–∏ –æ–±—Ä–æ–±–ª–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000);
                if (!isVisRunning) break;

                visContainer.style.transition = 'opacity 0.5s ease-in-out';
                visContainer.style.opacity = 0;
                await wait(500);
                if (!isVisRunning) break;
                
                logArea.innerHTML = '';
                visContainer.style.opacity = 1;
                await wait(500);
                visContainer.style.transition = '';
            }
        }

        // --- Tokenization Visualizer ---
        async function startTokenizationVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const sentences = [
                "the quick brown fox",
                "jumps over the lazy dog",
                "the lazy fox slept"
            ];

            workingArea.innerHTML = `
                <div class="tokenization-vis-container">
                    <div class="vis-token-main">
                        <div class="vis-sentence-area" id="vis-sentence-area"></div>
                        <div class="vis-vocab-area" id="vis-vocab-area"></div>
                        <div class="vis-sequence-area" id="vis-sequence-area"></div>
                    </div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;

            const logArea = document.getElementById('vis-log');
            const sentenceArea = document.getElementById('vis-sentence-area');
            const vocabArea = document.getElementById('vis-vocab-area');
            const sequenceArea = document.getElementById('vis-sequence-area');
            const visContainer = workingArea.querySelector('.tokenization-vis-container');

            const vocabulary = {};
            let nextTokenId = 1;

            while (isVisRunning) {
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ –ø—Ä–æ—Ü–µ—Å —Ç–æ–∫–µ–Ω—ñ–∑–∞—Ü—ñ—ó...");
                await wait(1500);

                for (const sentence of sentences) {
                    if (!isVisRunning) break;

                    // 1. Show sentence
                    sentenceArea.innerHTML = sentence.split(' ').map(word => `<span class="vis-word-token">${word}</span>`).join('');
                    sequenceArea.innerHTML = ''; // Clear previous sequence
                    addToVisLog(logArea, `–û–±—Ä–æ–±–∫–∞ —Ä–µ—á–µ–Ω–Ω—è: "${sentence}"`);
                    await wait(2000);
                    if (!isVisRunning) break;

                    // 2. Split into tokens
                    const wordTokens = sentenceArea.querySelectorAll('.vis-word-token');
                    addToVisLog(logArea, "–†–æ–∑–±–∏—Ç—Ç—è –Ω–∞ –æ–∫—Ä–µ–º—ñ —Ç–æ–∫–µ–Ω–∏...");
                    wordTokens.forEach(token => token.classList.add('spacing'));
                    await wait(1500);
                    if (!isVisRunning) break;

                    // 3. Build vocabulary and sequence
                    const currentSequence = [];
                    for (const token of wordTokens) {
                        if (!isVisRunning) break;
                        const word = token.textContent.toLowerCase();
                        token.classList.add('highlight');
                        
                        if (!vocabulary[word]) {
                            addToVisLog(logArea, `–ù–æ–≤–∏–π —Ç–æ–∫–µ–Ω '${word}'. –ü—Ä–∏—Å–≤–æ—î–Ω–Ω—è ID: ${nextTokenId}`);
                            vocabulary[word] = nextTokenId;
                            
                            const vocabEntry = document.createElement('div');
                            vocabEntry.className = 'vis-vocab-entry';
                            vocabEntry.id = `vocab-${word}`;
                            vocabEntry.innerHTML = `<span class="vis-vocab-id">${nextTokenId}:</span><span>${word}</span>`;
                            vocabArea.appendChild(vocabEntry);
                            await wait(50);
                            vocabEntry.classList.add('visible');

                            nextTokenId++;
                        } else {
                             addToVisLog(logArea, `–¢–æ–∫–µ–Ω '${word}' –≤–∂–µ —ñ—Å–Ω—É—î. ID: ${vocabulary[word]}`);
                             const existingEntry = document.getElementById(`vocab-${word}`);
                             if (existingEntry) {
                                 existingEntry.classList.add('highlight');
                             }
                        }
                        
                        currentSequence.push(vocabulary[word]);
                        sequenceArea.innerHTML = `[ ${currentSequence.join(', ')} ]`;

                        await wait(1500);
                        if (!isVisRunning) break;

                        token.classList.remove('highlight');
                        const existingEntry = document.getElementById(`vocab-${word}`);
                        if (existingEntry) {
                            existingEntry.classList.remove('highlight');
                        }
                        await wait(500);
                    }
                    if (!isVisRunning) break;
                    
                    addToVisLog(logArea, "–†–µ—á–µ–Ω–Ω—è —É—Å–ø—ñ—à–Ω–æ —Ç–æ–∫–µ–Ω—ñ–∑–æ–≤–∞–Ω–æ.");
                    await wait(2500);
                    if (!isVisRunning) break;
                }

                if (!isVisRunning) break;
                addToVisLog(logArea, "–í—Å—ñ —Ä–µ—á–µ–Ω–Ω—è –æ–±—Ä–æ–±–ª–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000);
                if (!isVisRunning) break;

                visContainer.style.transition = 'opacity 0.5s ease-in-out';
                visContainer.style.opacity = 0;
                await wait(500);
                if (!isVisRunning) break;
                
                // Reset for next full loop
                logArea.innerHTML = '';
                sentenceArea.innerHTML = '';
                vocabArea.innerHTML = '';
                sequenceArea.innerHTML = '';
                Object.keys(vocabulary).forEach(key => delete vocabulary[key]);
                nextTokenId = 1;
                
                visContainer.style.opacity = 1;
                await wait(500);
                visContainer.style.transition = '';
            }
        }
        
        // --- END: Visualization Functions ---

        // --- START: Call Visualization on initial load ---
        startDataCollectionVisualization();
        // --- END: Call Visualization on initial load ---

        function startDrag(e) {
            isDragging = true;
            document.body.style.cursor = 'grabbing';
            previousLevelIndex = currentLevelIndex;
            startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            dragMode = (e.target === handle) ? 'pending' : 'horizontal';
            segments.forEach((seg, i) => {
                seg.classList.remove('active');
                seg.style.height = '0px';
                seg.style.top = `${dotPositions[i]}px`;
            });
        }

        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            dragMode = 'none';
            document.body.style.cursor = 'default';
            handle.classList.remove('grabbing', 'flowing');
            clearTimeout(flowTimer);
            segments.forEach((seg, i) => {
                seg.classList.remove('active');
                setTimeout(() => {
                    if (!isDragging) {
                         seg.style.height = '0px';
                         seg.style.top = handle.style.top;
                    }
                }, 300);
            });
        }

        function onDrag(e) {
            if (!isDragging) return;

            const currentX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

            if (dragMode === 'pending') {
                const deltaX = Math.abs(currentX - startX);
                const deltaY = Math.abs(currentY - startY);
                if (deltaY > 10) dragMode = 'vertical';
                else if (deltaX > 10) dragMode = 'horizontal';
                else return;
            }

            if (dragMode === 'vertical') {
                e.preventDefault();

                const scrollerRect = scroller.getBoundingClientRect();
                const mouseY = currentY - scrollerRect.top;
                let closestDotY = dotPositions.reduce((prev, curr) => (Math.abs(curr - mouseY) < Math.abs(prev - mouseY) ? curr : prev));
                handle.style.top = `${closestDotY}px`;

                let closestIndex = dotPositions.indexOf(closestDotY);
                if (closestIndex !== -1 && closestIndex !== currentLevelIndex) {
                    handle.classList.add('grabbing', 'flowing');
                    clearTimeout(flowTimer);
                    flowTimer = setTimeout(() => {
                        handle.classList.remove('flowing', 'grabbing');
                        segments.forEach(seg => seg.classList.remove('active'));
                    }, 400);

                    const direction = closestIndex > currentLevelIndex ? 1 : -1;
                    const transitionDelay = 200;
                    const slideDistance = 15;

                    titleEn.style.opacity = 0;
                    titleEn.style.transform = `translateY(${direction * slideDistance}px)`;
                    titleUa.style.opacity = 0;
                    titleUa.style.transform = `translateY(${direction * slideDistance}px)`;

                    currentLevelIndex = closestIndex;

                    const startIdx = Math.min(previousLevelIndex, currentLevelIndex);
                    const endIdx = Math.max(previousLevelIndex, currentLevelIndex);

                    segments.forEach((segment, i) => {
                        if (i >= startIdx && i < endIdx) {
                            segment.style.top = `${dotPositions[i]}px`;
                            segment.style.height = `${dotPositions[i+1] - dotPositions[i]}px`;
                            segment.classList.add('active');
                        } else {
                            segment.style.height = '0px';
                            segment.classList.remove('active');
                        }
                    });

                    // --- START: Visualization Trigger Logic ---
                    if (previousLevelIndex !== currentLevelIndex) {
                        clearVisualization(); // Clear any running visualization first
                        setTimeout(() => { // Use a timeout to let the old one clear fully
                            if (currentLevelIndex === 6) {
                                startDataCollectionVisualization();
                            } else if (currentLevelIndex === 5) {
                                startPreprocessingVisualization();
                            } else if (currentLevelIndex === 4) {
                                startTokenizationVisualization();
                            }
                        }, 10); // A tiny delay is enough
                    }
                    // --- END: Visualization Trigger Logic ---

                    previousLevelIndex = currentLevelIndex;

                    setTimeout(() => {
                        titleEn.textContent = levelData[currentLevelIndex].en;
                        titleUa.textContent = levelData[currentLevelIndex].ua;
                        titleEn.style.transition = 'none';
                        titleUa.style.transition = 'none';
                        titleEn.style.transform = `translateY(${-direction * slideDistance}px)`;
                        titleUa.style.transform = `translateY(${-direction * slideDistance}px)`;
                        titleEn.offsetHeight;
                        titleEn.style.transition = 'opacity 0.2s ease-in-out, transform 0.2s ease-in-out';
                        titleUa.style.transition = 'opacity 0.2s ease-in-out, transform 0.2s ease-in-out';
                        titleEn.style.opacity = 1;
                        titleEn.style.transform = 'translateY(0)';
                        titleUa.style.opacity = 1;
                        titleUa.style.transform = 'translateY(0)';
                    }, transitionDelay);
                }
            }
            
            if (dragMode === 'horizontal') {
                e.preventDefault();
                const screenWidth = window.innerWidth;
                const isRightSide = topGroup.classList.contains('right');
                const dragDistance = currentX - startX;
                const minDrag = (screenWidth / 2) - 10;

                if (isRightSide && dragDistance < -minDrag) {
                    topGroup.classList.remove('right');
                    mainContentWrapper.classList.remove('right');
                    endDrag(e);
                } else if (!isRightSide && dragDistance > minDrag) {
                    topGroup.classList.add('right');
                    mainContentWrapper.classList.add('right');
                    endDrag(e);
                }
            }
        }

        // Event Listeners
        scroller.addEventListener('mousedown', startDrag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', onDrag);
        scroller.addEventListener('touchstart', startDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchmove', onDrag);
    });
</script>
</body>
</html>
