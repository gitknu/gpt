<!--–ü–µ—Ä–µ–ø—Ä–æ—à—É—é –∑–∞ —Å–º—ñ—Ç—Ç–Ω–∏–∫ —ñ–∑ –∫–æ–¥—É, –≤—ñ–¥—Å—É—Ç–Ω—ñ—Å—Ç—å —Å–º–∞–∫—É –≤ PDF —Ç–∞ –Ω–µ—Ç–æ—á–Ω–æ—Å—Ç—ñ —É –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è—Ö - –ø'—è—Ç–Ω–∏—Ü—è –≤–µ—á—ñ—Ä))) –ó–≤–µ—Ä—Ç–∞–π—Ç–µ—Å—è —É —Ä–∞–∑—ñ —á–æ–≥–æ. –í—ñ–¥–ø–æ–≤—ñ–º —Ç–∞–∫, –∞ —Å–∏–ª—å–Ω–æ –∫—Ä–∏—Ç–∏—á–Ω—ñ –ø—Ä–∞–≤–∫–∏ –º–æ–∂–ª–∏–≤–æ —ñ –¥–æ–≤–Ω–µ—Å—É-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–Ø–∫ —Å—Ç–≤–æ—Ä–∏—Ç–∏ GPT</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- Updated to include font-weight 800 for extrabold -->
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;800&display=swap" rel="stylesheet">
<!-- --- START: EDITED BY GEMINI --- -->
<!-- Added jsPDF library for PDF generation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<!-- --- END: EDITED BY GEMINI --- -->
<style>
    body, html {
        height: 100%;
        margin: 0;
        padding: 0;
        background-color: white;
        display: flex;
        flex-direction: column; /* Stack items vertically */
        font-family: sans-serif;
        box-sizing: border-box; /* Ensure padding/borders don't add to height */
        overflow-x: hidden; /* Prevent horizontal scrollbars */
    }

    .top-group {
        width: 100%;
        padding: 0 50px;
        margin-top: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }


    /* --- START: EDITED BY GEMINI --- */
    .data-title-container {
        font-family: 'Montserrat', sans-serif;
        color: black;
        margin: 0;
        height: 86px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        user-select: none;
        align-items: center;
        
        /* This makes the container full-width, breaking out of the parent's padding */
        width: 100vw;
        position: relative;
        left: 50%;
        transform: translateX(-50%);
    }
    /* --- END: EDITED BY GEMINI --- */

    .title-en {
        font-weight: 800; /* Extrabold */
        font-size: clamp(1.8rem, 4.2vw, 2.6rem);
        line-height: 1.2;
        text-align: center;
        color: #b80000;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        white-space: nowrap; /* Ensure text stays on one line */
        padding: 0 20px; /* Add padding to the text itself so it never touches the edges */
        box-sizing: border-box;
    }

    .title-ua {
        font-weight: 800; /* Extrabold - CHANGED */
        font-size: clamp(1.1rem, 2.3vw, 1.5rem);
        line-height: 1.2;
        text-align: center;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        white-space: nowrap; /* Ensure text stays on one line */
        padding: 0 20px; /* Add padding to the text itself so it never touches the edges */
        box-sizing: border-box;
    }


    .scroller-hint {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500; /* Not bold, as requested */
        font-size: 0.675rem; /* 75% of original 0.9rem */
        color: #cccccc; /* Barely visible grey color */
        margin-top: 8px; /* Space from title */
        margin-bottom: 0; /* No extra space, scroller has its own */
        align-self: center;
        text-align: center;
        user-select: none;
    }

    .scroller-hint .arrow-left {
        display: inline; /* Show left arrow by default (scroller is on the left) */
    }
    .scroller-hint .arrow-right {
        display: none; /* Hide right arrow by default */
    }

    .top-group.right .scroller-hint .arrow-left {
        display: none; /* Hide left arrow when scroller is on the right */
    }
    .top-group.right .scroller-hint .arrow-right {
        display: inline; /* Show right arrow when scroller is on the right */
    }

    .main-content-wrapper {
        flex-grow: 1; /* This wrapper fills the vertical space */
        width: 100%;
        box-sizing: border-box;
        margin: 10px 0 0 0;
        padding: 0 50px;
        position: relative; /* CRITICAL: For absolute positioning child */
    }


    /* --- START: Scroller Styles --- */
    .scroller-container {
        margin-top: 0;
        height: 514px; /* 6/7ths of original 600px */
        width: 9px;
        background-color: transparent;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        position: absolute; /* CRITICAL: Now absolutely positioned */
        top: 0; /* Align to top of wrapper */
        left: 50px; /* Matched new padding */
        transition: left 0.4s cubic-bezier(0.65, 0, 0.35, 1);
    }

    .scroller-container::before {
        content: '';
        position: absolute;
        width: 4px;
        height: 100%;
        background-color: black;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1;
    }

    .thick-segment {
        position: absolute;
        width: 4px; /* Start at thin width */
        background-color: black;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2; /* Above thin line */
        height: 0; /* Controlled by JS */
        top: 0; /* Controlled by JS */
        transition: width 0.3s cubic-bezier(0.65, 0, 0.35, 1);
    }

    .thick-segment.active {
        width: 9px; /* Animate to thick width */
    }

    .dot {
        width: 20px;
        height: 20px;
        background-color: black;
        border-radius: 50%;
        flex-shrink: 0;
        position: relative;
        z-index: 3; /* Above thick line */
    }

    #scroller-handle {
        width: 36px; /* This is the outer black dot */
        height: 36px;
        background-color: black;
        border-radius: 50%;
        position: absolute;
        left: 50%;
        transform: translate(-50%, -50%) scale(1);
        cursor: grab;
        transition: top 0.4s cubic-bezier(0.65, 0, 0.35, 1),
                    transform 0.3s cubic-bezier(0.65, 0, 0.35, 1);
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 4; /* Topmost element */
    }

    #scroller-handle::before {
        content: '';
        display: block;
        width: 18px;
        height: 18px;
        background-color: #0b5394; /* The blue liquid */
        border-radius: 50%;
        transform: scale(1);
        transition: transform 0.3s cubic-bezier(0.65, 0, 0.35, 1);
    }

    #scroller-handle.grabbing {
        transform: translate(-50%, -50%) scaleX(0.25) scaleY(1);
        cursor: grabbing;
    }

    #scroller-handle.grabbing::before {
        transform: scaleX(2) scaleY(0.5);
    }

    /* --- ADDED: This is the "flowing" state --- */
    #scroller-handle.grabbing.flowing::before {
        transform: scaleX(2) scaleY(2.0);
    }

    #scroller-handle:active {
        cursor: grabbing;
    }

    .working-area {
        border: 2px dashed black;
        border-radius: 10px;
        /* CRITICAL: Set fixed margins on BOTH sides */
        margin-left: 24px;
        margin-right: 24px;
        /* ADDED: Set height to match scroller */
        height: 514px;
        box-sizing: border-box; /* Account for border */
        /* --- START: Added by Gemini for visualization --- */
        padding: 20px;
        font-family: 'Courier New', Courier, monospace;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Hide overflow from animations */
        /* --- END: Added by Gemini for visualization --- */
    }

    .main-content-wrapper.right .scroller-container {
        left: calc(100% - 50px - 9px); /* Matched new padding */
    }

    /* --- START: EDITED BY GEMINI --- */
    .bottom-content-wrapper {
        margin-top: auto; /* Pushes this entire block to the bottom */
        width: 100%;
        padding-bottom: 20px; /* Add some space at the very bottom */
    }

    .pdf-download-container {
        width: 100%;
        text-align: center;
        margin-bottom: 10px; /* Space between PDF link and logos */
    }
    
    /* --- START: ADDED BY GEMINI --- */
    .contact-link-container {
        width: 100%;
        text-align: center;
        margin-bottom: 20px; /* Space between contact link and logos */
    }

    #pdf-download-link,
    #contact-link {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500;
        color: #0b5394;
        cursor: pointer;
        text-decoration: underline;
        font-size: 16px;
        margin: 0;
        display: inline-block;
        transition: color 0.2s ease-in-out;
    }
    #pdf-download-link:hover,
    #contact-link:hover {
        color: #b80000;
    }
    /* --- END: ADDED BY GEMINI --- */

    .logo-container {
        display: flex;
        flex-direction: row;
        align-items: flex-end;
        gap: 15px;
        width: 100%;
        justify-content: center;
        /* margin-top: auto; Pushes logos to the bottom - MOVED to wrapper */
        box-sizing: border-box;
        padding: 0 40px;
    }

    .logo-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }

    .logo-label {
        font-family: 'Montserrat', sans-serif;
        font-weight: 500;
        font-size: 12px; /* 75% of 16px */
        color: #333;
        margin-bottom: 10px; /* Space between text and logo */
    }

    .logo-link {
        display: inline-block;
    }

    .logo {
        width: 90px;
        height: auto;
        transition: transform 0.2s ease-in-out;
    }
    /* --- END: EDITED BY GEMINI --- */

    .logo:hover {
        transform: scale(1.1);
    }

    .vis-log {
        margin-top: 15px;
        height: 100px; /* Fixed height for log area */
        width: 100%;
        /* --- EDITED FOR MATRIX THEME --- */
        background-color: #000000;
        border-top: 1px solid #00FF00;
        padding: 10px;
        box-sizing: border-box;
        /* --- END EDITS --- */
        overflow-y: auto;
        font-size: 0.85rem;
        font-family: 'Courier New', Courier, monospace;
        flex-shrink: 0; /* Prevent log from shrinking */
    }
    .vis-log-entry {
        margin-bottom: 5px;
        /* --- EDITED FOR MATRIX THEME --- */
        color: #00FF00;
        text-shadow: 0 0 4px #00FF00;
        /* --- END EDITS --- */
    }

    /* --- START: Data Collection Visualization Styles --- */
    .data-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: 'Montserrat', sans-serif;
        color: black;
    }
    .vis-main-area {
        width: 100%;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        position: relative;
        min-height: 0;
    }
    .vis-sources-row {
        display: flex;
        justify-content: center;
        gap: 30px;
        width: 100%;
    }
    .vis-source {
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: transform 0.3s, opacity 0.3s;
    }
    .vis-source-icon { font-size: 2.5rem; }
    .vis-source-url {
        font-size: 0.7rem;
        margin-top: 5px;
        font-family: 'Courier New', Courier, monospace;
    }
    .vis-source.pending { opacity: 0.4; }
    .vis-source.active {
        transform: scale(1.1);
        font-weight: bold;
    }
    .vis-source.done { opacity: 0.2; }
    .vis-scraper-icon {
        font-size: 4rem;
        animation: gentle-bob 2s infinite ease-in-out;
    }
    @keyframes gentle-bob {
        0% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0); }
    }
    .vis-storage-icon { font-size: 3.5rem; }
    .vis-data-packet {
        position: absolute;
        font-size: 2rem;
        opacity: 0;
        z-index: 10;
    }
    /* --- END: Data Collection Visualization Styles --- */

    /* --- START: Preprocessing Visualization Styles (Added by Gemini) --- */
    .preprocessing-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between; /* CHANGED for storage icon */
        font-family: 'Montserrat', sans-serif;
        color: black;
        position: relative; /* ADDED for packet positioning */
    }
    .vis-text-area {
        /* --- FONT EDITED FOR CONSISTENCY --- */
        font-family: 'Courier New', Courier, monospace;
        font-size: 1.1rem; /* EDITED: Slightly smaller */
        line-height: 1.5; /* EDITED: Tighter line spacing */
        padding: 15px; /* EDITED: Reduced padding */
        text-align: justify;
        border: 1px solid #eee;
        border-radius: 5px;
        width: 100%;
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 120px; /* EDITED: Reduced min-height */
    }
    .error-highlight {
        background-color: #ffdddd;
        border-radius: 3px;
        transition: all 0.3s ease-in-out;
    }
    .error-fixing {
        background-color: #ddffdd;
        text-decoration: line-through;
        opacity: 0.5;
    }
    .corrected-text {
        background-color: #ddffdd;
        font-weight: bold;
        transition: all 0.3s ease-in-out;
    }
    .vis-file-packet {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 2rem;
        opacity: 0;
        z-index: 10;
        transition: top 1s ease-in-out, left 1s ease-in-out, opacity 0.5s, transform 1s ease-in-out;
    }
    .vis-file-packet-name {
        font-size: 0.7rem;
        margin-top: 5px;
        font-family: 'Courier New', Courier, monospace;
        background-color: white;
        padding: 2px 4px;
        border-radius: 3px;
        border: 1px solid #ccc;
        transition: background-color: 0.3s ease-in-out;
    }
    /* --- END: Preprocessing Visualization Styles --- */

    /* --- START: Tokenization Visualization Styles --- */
    .tokenization-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        font-family: 'Montserrat', sans-serif;
        color: black;
    }
    .vis-token-main {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between; /* EDITED: Changed from space-around */
        align-items: center;
    }
    .vis-sentence-area {
        font-size: 1.4rem; /* EDITED: Slightly smaller */
        font-family: 'Courier New', Courier, monospace;
        padding: 8px; /* EDITED: Reduced padding */
        border: 1px solid #ccc;
        border-radius: 5px;
        min-height: 40px; /* EDITED: Reduced min-height */
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        width: 90%;
    }
    .vis-word-token {
        display: inline-block;
        padding: 4px; /* EDITED: Reduced padding */
        margin: 0;
        border-radius: 4px;
        transition: all 0.5s ease-in-out;
    }
    .vis-word-token.highlight {
        background-color: #f0e68c; /* Khaki */
        transform: scale(1.1);
    }
    .vis-word-token.spacing {
        margin: 0 8px; /* EDITED: Reduced margin */
    }
    .vis-vocab-area {
        width: 90%;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px; /* EDITED: Reduced gap */
        min-height: 70px; /* EDITED: Reduced min-height */
        border: 1px dashed #aaa;
        padding: 8px; /* EDITED: Reduced padding */
        border-radius: 5px;
    }
    .vis-vocab-entry {
        background-color: #e0e0e0;
        padding: 4px 8px; /* EDITED: Reduced padding */
        border-radius: 15px;
        font-size: 0.85rem; /* EDITED: Slightly smaller */
        opacity: 0;
        transform: scale(0.5);
        transition: all 0.5s ease-in-out;
    }
    .vis-vocab-entry.visible {
        opacity: 1;
        transform: scale(1);
    }
     .vis-vocab-entry.highlight {
        background-color: #add8e6; /* Light Blue */
        box-shadow: 0 0 10px #add8e6;
    }
    .vis-vocab-id {
        font-weight: bold;
        color: #b80000;
        margin-right: 6px; /* EDITED: Reduced margin */
    }
    .vis-sequence-area {
        font-size: 1.4rem; /* EDITED: Slightly smaller */
        font-family: 'Courier New', Courier, monospace;
        letter-spacing: 4px; /* EDITED: Tighter spacing */
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 12px; /* EDITED: Reduced padding */
        min-height: 40px; /* EDITED: Reduced min-height */
        width: 90%;
        text-align: center;
    }
    /* --- END: Tokenization Visualization Styles --- */

    /* --- START: Pretraining Visualization Styles --- */
    .pretraining-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: 'Montserrat', sans-serif;
        color: black;
    }
    .pretraining-phase {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        transition: opacity 0.5s ease-in-out;
    }
    .pretraining-phase.hidden {
        display: none;
        opacity: 0;
    }
    /* Phase 1: Connection Building */
    .vis-corpus-analysis-area {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between; /* EDITED: Changed from space-around */
    }
    .vis-corpus-text-area {
        font-size: 1.2rem; /* EDITED: Slightly smaller */
        font-family: 'Courier New', Courier, monospace;
        padding: 10px; /* EDITED: Reduced padding */
        border: 1px solid #eee;
        border-radius: 5px;
        line-height: 1.7; /* EDITED: Adjusted */
        position: relative;
    }
    .vis-corpus-word {
        transition: background-color: 0.3s;
    }
    .vis-scan-window {
        position: absolute;
        border: 2px solid #0b5394;
        border-radius: 5px;
        background-color: rgba(11, 83, 148, 0.1);
        transition: left 0.5s ease-in-out, width 0.5s ease-in-out;
    }
    .vis-corpus-word.active-pair {
        background-color: #f0e68c;
    }
    .vis-weight-matrix-area {
        display: grid;
        grid-template-columns: repeat(6, 1fr); /* Adjust based on vocab size */
        gap: 3px; /* EDITED: Reduced gap further */
        font-size: 0.7rem; /* EDITED: Slightly smaller */
    }
    .vis-weight-cell {
        border: 1px solid #ccc;
        border-radius: 4px;
        text-align: center;
        padding: 1px; /* EDITED: Reduced padding further */
        transition: background-color 0.3s, transform 0.2s;
        overflow: hidden; /* EDITED: Prevent overflow within cell */
    }
    .vis-weight-cell .token-pair {
        font-size: 0.55rem; /* EDITED: Smaller */
        color: #888;
    }
    .vis-weight-cell .weight-value {
        font-weight: bold;
        font-family: 'Courier New', Courier, monospace;
        font-size: 0.7rem; /* EDITED: Made slightly smaller */
    }
    .vis-weight-cell.highlight-update {
        background-color: #ddffdd;
        transform: scale(1.1);
    }
    .vis-weight-cell.highlight-predict {
        background-color: rgba(173, 216, 230, 0.7); /* Light Blue */
    }
    /* Phase 2: Masked Prediction */
    .vis-prediction-area {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
    }
    .vis-model-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 15px; /* EDITED: Reduced margin */
    }
    .vis-model-icon {
        font-size: 3.5rem; /* EDITED: Smaller */
        animation: model-pulse 2.5s infinite ease-in-out;
    }
    @keyframes model-pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    .vis-knowledge-gears { font-size: 1.4rem; margin-top: -10px; opacity: 0.7; }
    .vis-knowledge-gears .gear1 { display: inline-block; animation: spin-clockwise 5s linear infinite; }
    .vis-knowledge-gears .gear2 { display: inline-block; animation: spin-counter-clockwise 5s linear infinite; margin-left: -8px; }
    @keyframes spin-clockwise { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    @keyframes spin-counter-clockwise { from { transform: rotate(0deg); } to { transform: rotate(-360deg); } }
    .vis-text-processing-area {
        font-size: 1.3rem; /* EDITED: Slightly smaller */
        font-family: 'Courier New', Courier, monospace;
        padding: 12px; /* EDITED: Reduced padding */
        border: 1px solid #ccc;
        border-radius: 5px;
        min-height: 50px; /* EDITED: Reduced min-height */
        width: 100%;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
    }
    .vis-masked-word { background-color: #ffd700; color: black; padding: 2px 8px; border-radius: 4px; font-weight: bold; position: relative; }
    .vis-prediction-popup {
        position: absolute;
        bottom: 110%; left: 50%;
        transform: translateX(-50%);
        background-color: white; border: 1px solid black; border-radius: 5px;
        padding: 5px 10px; font-size: 1rem; opacity: 0;
        transition: opacity 0.3s, transform 0.3s;
        white-space: nowrap;
    }
    .vis-prediction-popup.visible { opacity: 1; transform: translateX(-50%) translateY(-5px); }
    .vis-prediction-popup.correct { background-color: #ddffdd; border-color: green; }
    .vis-prediction-popup.incorrect { background-color: #ffdddd; border-color: red; text-decoration: line-through; }
    .vis-stats-area { width: 100%; display: flex; justify-content: space-around; padding: 8px; font-size: 0.9rem; font-family: 'Montserrat', sans-serif; }
    /* --- END: Pretraining Visualization Styles --- */

    /* --- START: Finetuning Visualization Styles --- */
    .finetuning-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        font-family: 'Montserrat', sans-serif;
        color: black;
        position: relative; /* ADDED for dataset overlay */
    }
    /* NEW: Dataset Area for initial loading animation */
    .vis-qa-dataset-area {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-height: 80%;
        background: #ffffff;
        border: 2px solid #0b5394;
        border-radius: 8px;
        padding: 15px;
        z-index: 20;
        transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out; /* ADDED transform */
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
    }
    .vis-qa-dataset-area strong {
        font-weight: 800;
        margin-bottom: 10px;
        text-align: center;
        flex-shrink: 0;
    }
    .vis-qa-dataset-list {
        overflow-y: auto; /* For long lists */
    }
    .vis-qa-pair-item {
        font-family: 'Courier New', monospace;
        font-size: 0.9rem; /* EDITED: Smaller font */
        padding: 4px; /* EDITED: Tighter padding */
        border-bottom: 1px solid #eee;
        transition: transform 0.8s ease-in, opacity 0.8s ease-in;
        opacity: 1;
        transform: translateX(0);
    }
    .vis-qa-pair-item span { color: #b80000; }
    .vis-qa-pair-item.feeding {
        transform: translateX(50px);
        opacity: 0;
    }

    .vis-finetuning-main {
        flex-grow: 1;
        display: flex;
        align-items: center;
        gap: 20px;
        transition: opacity 0.5s ease-in-out; /* Added for fade-in */
    }
    .vis-qa-area {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 10px; /* EDITED: Reduced gap */
        height: 100%;
        justify-content: center;
    }
    .vis-prompt-box, .vis-response-box {
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 12px; /* EDITED: Reduced padding */
        background-color: #f9f9f9;
    }
    .vis-prompt-box strong, .vis-response-box strong {
        font-weight: 800;
        color: #333;
        display: block;
        margin-bottom: 6px; /* EDITED: Reduced margin */
    }
    #vis-prompt-text, #vis-model-response-text, #vis-target-response-text {
        font-family: 'Courier New', Courier, monospace;
        font-size: 1.1rem; /* EDITED: Smaller */
        min-height: 1.5em; /* EDITED: Smaller min-height */
    }
    .vis-response-comparison {
        display: flex;
        flex-direction: column;
        gap: 10px; /* EDITED: Reduced gap */
    }
    .vis-response-box {
        transition: border-color 0.5s, background-color 0.5s;
    }
    .vis-response-box.incorrect {
        border-color: #b80000;
        background-color: #ffdddd;
    }
    .vis-response-box.correct {
        border-color: #006400;
        background-color: #ddffdd;
    }
    .vis-model-area-ft { /* ft for finetuning */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px; /* EDITED: Reduced gap */
    }
    .vis-update-arrow {
        font-size: 2.5rem; /* EDITED: Smaller */
        opacity: 0;
        transform: translateY(-20px);
        transition: opacity 0.4s, transform 0.4s;
    }
    .vis-update-arrow.visible {
        opacity: 1;
        transform: translateY(0);
    }
    .text-correction {
        text-decoration: line-through;
        opacity: 0.6;
        background-color: #ffc8c8;
        padding: 0 2px;
        border-radius: 3px;
    }
    .text-corrected {
        background-color: #c8ffc8;
        font-weight: bold;
        padding: 0 2px;
        border-radius: 3px;
    }
    /* --- END: Finetuning Visualization Styles --- */

    /* --- START: Reward Model Training Visualization Styles --- */
    .reward-model-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        font-family: 'Montserrat', sans-serif;
        color: black;
    }
    .reward-model-main {
        flex-grow: 1;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 15px; /* EDITED: Reduced gap */
        position: relative; /* For packet animation */
    }
    .vis-responses-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px; /* EDITED: Reduced gap */
        position: relative; /* For ranker icon */
    }
    .vis-response-box-rm { /* rm for reward model */
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 8px; /* EDITED: Reduced padding */
        background-color: #f9f9f9;
        font-family: 'Courier New', Courier, monospace;
        font-size: 0.9rem; /* EDITED: Smaller font */
        transition: all 0.4s ease-in-out;
        position: relative; /* For score positioning */
    }
    .vis-response-box-rm.preferred {
        border-color: #006400;
        background-color: #ddffdd;
        transform: scale(1.02);
    }
    .vis-human-ranker {
        position: absolute;
        font-size: 2rem; /* EDITED: Smaller */
        left: -35px; /* EDITED: Adjusted position to be safely inside */
        top: 0;
        opacity: 0;
        transition: all 0.8s cubic-bezier(0.65, 0, 0.35, 1);
    }
    .vis-reward-model-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    .vis-reward-model-icon {
        font-size: 3.5rem; /* EDITED: Smaller */
        position: relative;
    }
    .vis-reward-model-icon .gears {
        position: absolute;
        font-size: 1.5rem;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        transition: opacity 0.3s;
    }
    .vis-reward-model-icon.training .gears {
        opacity: 0.7;
    }
    .vis-reward-score {
        position: absolute;
        top: -8px; /* EDITED: Adjusted position */
        right: -8px; /* EDITED: Adjusted position */
        background-color: #0b5394;
        color: white;
        padding: 3px 6px; /* EDITED: Reduced padding */
        border-radius: 15px;
        font-size: 0.8rem; /* EDITED: Smaller font */
        font-weight: bold;
        transform: scale(0);
        transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    }
    .vis-reward-score.visible {
        transform: scale(1);
    }
    .vis-reward-data-packet {
        position: absolute;
        font-size: 2rem;
        padding: 5px;
        border: 1px solid black;
        border-radius: 5px;
        background-color: white;
        opacity: 0;
        transition: all 1s ease-in-out;
        z-index: 10;
        transform: scale(0.5);
    }
    /* --- END: Reward Model Training Visualization Styles --- */

    /* --- START: RLHF Visualization Styles --- */
    .rlhf-vis-container {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        font-family: 'Montserrat', sans-serif;
        color: black;
    }
    .rlhf-main {
        flex-grow: 1;
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        grid-template-rows: auto 1fr;
        align-items: center;
        gap: 15px;
        position: relative;
    }
    .rlhf-prompt-area {
        grid-column: 1 / -1;
        text-align: center;
    }
    .rlhf-model-area, .rlhf-reward-model-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    .rlhf-interaction-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
    }
    .rlhf-response {
        border: 1px solid #ccc;
        padding: 8px;
        border-radius: 5px;
        font-size: 0.9rem;
        font-family: 'Courier New', monospace;
        background-color: #f9f9f9;
        transition: all 0.3s;
        opacity: 0;
        transform: scale(0.9);
        cursor: pointer;
    }
    .rlhf-response:hover {
        border-color: #0b5394;
        transform: scale(1.03) !important;
    }
    .rlhf-response.chosen {
        border-color: #006400;
        background-color: #ddffdd;
    }
    .rlhf-response.not-chosen {
        opacity: 0.4 !important;
        border-color: #b80000;
        background-color: #ffdddd;
    }
    .blinking-question-mark {
        font-size: 2.5rem;
        animation: blink 1.5s infinite ease-in-out;
    }
    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.2; }
    }
    .rlhf-reward-signal {
        position: absolute;
        font-size: 1.5rem;
        opacity: 0;
        transition: all 0.8s ease-in-out;
    }
    /* --- END: RLHF Visualization Styles --- */

    /* --- Mobile Responsivity --- */
    @media (max-width: 600px) {

        /* Adjust top group for mobile */
        .top-group {
            padding: 0 40px;
            margin-top: 10px;
        }

        /* Adjust title for mobile */
        .data-title-container {
            height: 57px; /* 1/7th of original 400px */
        }

        .title-en {
            font-size: clamp(1.4rem, 5.5vw, 1.8rem);
        }

        .title-ua {
            font-size: clamp(0.8rem, 3.5vw, 1.1rem);
        }


        /* --- ADDED: Mobile hint styles --- */
        .scroller-hint {
            font-size: 0.6rem; /* 75% of 0.8rem */
            margin-top: 4px;
        }

        .main-content-wrapper {
            margin: 10px 0 0 0;
            padding: 0 40px;
        }

        .scroller-container {
            margin-top: 0;
            height: 343px; /* 6/7ths of original 400px */
            left: 40px;
        }

        .main-content-wrapper.right .scroller-container {
            left: calc(100% - 40px - 9px);
        }

        .dot {
            width: 16px;
            height: 16px;
        }

        #scroller-handle {
            width: 24px;
            height: 24px;
        }

        #scroller-handle::before {
            width: 10px;
            height: 10px;
        }

        .working-area {
            margin-left: 12px;
            margin-right: 12px;
            height: 343px;
            box-sizing: border-box;
            padding: 10px;
            font-size: 0.8rem;
        }
        
        /* Data collection mobile styles */
        .vis-sources-row { gap: 10px; } /* EDITED: Reduced gap */
        .vis-source-icon { font-size: 1.8rem; } /* EDITED: Smaller */
        .vis-source-url { font-size: 0.55rem; } /* EDITED: Smaller */
        .vis-scraper-icon { font-size: 2.8rem; } /* EDITED: Smaller */
        .vis-storage-icon { font-size: 2.8rem; } /* EDITED: Smaller */
        
        .vis-log {
            height: 60px;
            font-size: 0.7rem; /* EDITED: Slightly smaller */
            margin-top: 10px;
        }

        /* Preprocessing mobile styles (Added by Gemini) */
        .vis-text-area {
            font-size: 0.8rem; /* EDITED: Smaller */
            line-height: 1.4; /* EDITED: Tighter */
            padding: 8px; /* EDITED: Reduced padding */
            min-height: 80px; /* EDITED: Reduced min-height */
        }
        
        /* Tokenization mobile styles */
        .vis-sentence-area { font-size: 0.9rem; min-height: 30px; } /* EDITED */
        .vis-word-token.spacing { margin: 0 2px; }
        .vis-vocab-area { min-height: 50px; gap: 4px; } /* EDITED */
        .vis-vocab-entry { font-size: 0.7rem; padding: 2px 6px; } /* EDITED */
        .vis-sequence-area { font-size: 0.9rem; padding: 8px; min-height: 30px; } /* EDITED */
        
        /* --- START: Pretraining mobile styles (EDITED) --- */
        .vis-corpus-text-area {
            font-size: 0.8rem; /* EDITED: Smaller */
            padding: 8px;    /* EDITED: Reduced padding */
            line-height: 1.5; /* EDITED: Adjusted line height */
        }
        .vis-weight-matrix-area {
            grid-template-columns: repeat(3, 1fr);
            gap: 2px; /* EDITED: Reduced gap */
        }
        .vis-weight-cell {
            padding: 1px; /* EDITED: Reduced padding */
        }
        .vis-weight-cell .token-pair {
            font-size: 0.45rem; /* EDITED BY GEMINI: Made even smaller for mobile */
        }
        .vis-weight-cell .weight-value {
            font-size: 0.7rem; /* EDITED: Adjusted */
        }
        .vis-model-icon { font-size: 2.8rem; } /* EDITED: Smaller */
        .vis-knowledge-gears { font-size: 1.1rem; } /* EDITED: Smaller */
        .vis-text-processing-area { font-size: 0.9rem; min-height: 40px; padding: 8px; } /* EDITED */
        .vis-stats-area { font-size: 0.75rem; padding: 5px; } /* EDITED */
        /* --- END: Pretraining mobile styles (EDITED) --- */

        /* --- START: Finetuning mobile styles --- */
        /* NEW Mobile styles for finetuning data loading */
        .vis-qa-dataset-area {
            width: 90%;
            padding: 10px;
        }
        .vis-qa-pair-item {
            font-size: 0.75rem; /* EDITED: Smaller */
        }
        .vis-finetuning-main {
            flex-direction: column;
            gap: 8px; /* EDITED: Reduced gap */
        }
        .vis-qa-area {
            width: 100%;
            gap: 8px; /* EDITED: Reduced gap */
        }
        .vis-prompt-box, .vis-response-box {
            padding: 8px; /* EDITED: Reduced padding */
        }
        #vis-prompt-text, #vis-model-response-text, #vis-target-response-text {
            font-size: 0.8rem; /* EDITED: Smaller */
            min-height: 1.5em;
        }
        .vis-model-area-ft {
            flex-direction: row;
            align-items: center;
            gap: 15px;
        }
        .vis-update-arrow {
            font-size: 2rem;
            transform: none; /* Reset transform */
            animation: arrow-pulse 1s infinite;
        }
        @keyframes arrow-pulse { 0% {transform: scale(1);} 50% {transform: scale(1.2);} 100% {transform: scale(1);} }
        .finetuning-vis-container .vis-stats-area { display: none; } /* Hide stats on mobile for space */
        /* --- END: Finetuning mobile styles --- */

        /* --- START: Reward Model mobile styles --- */
        .reward-model-main {
            flex-direction: column;
            gap: 10px; /* EDITED: Reduced gap */
        }
        .vis-responses-area { width: 100%; }
        .vis-prompt-box { padding: 8px; } /* EDITED */
        .vis-prompt-box strong { font-size: 0.8rem; } /* EDITED */
        .vis-prompt-box div { font-size: 0.8rem; } /* EDITED */
        .vis-response-box-rm { font-size: 0.75rem; padding: 6px; } /* EDITED */
        .vis-human-ranker { font-size: 1.8rem; left: -25px; } /* EDITED */
        .vis-reward-model-area { flex-direction: row; align-items: center; }
        .vis-reward-model-icon { font-size: 2.8rem; } /* EDITED */
        .vis-reward-score { font-size: 0.7rem; padding: 2px 5px; top: -5px; right: -5px;} /* EDITED */
        /* --- END: Reward Model mobile styles --- */
        
        /* --- START: RLHF mobile styles --- */
        .rlhf-main {
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto auto;
            gap: 5px;
        }
        .rlhf-model-area { grid-row: 2; }
        .rlhf-interaction-area { grid-row: 3; }
        .rlhf-reward-model-area { grid-row: 4; }
        .rlhf-response { font-size: 0.75rem; }
        .blinking-question-mark { font-size: 1.8rem; }
        /* --- END: RLHF mobile styles --- */

        /* --- START: EDITED BY GEMINI --- */
        #pdf-download-link,
        #contact-link {
            font-size: 14px;
        }
        
        .logo-container {
            padding: 0 20px;
            margin-bottom: 0;
            gap: 10px;
            flex-wrap: wrap; /* --- ADDED: Prevents horizontal overflow --- */
        }
        .logo {
            width: 60px;
        }
        .logo-label {
            font-size: 11px; /* 75% of 14px */
        }
        /* --- END: EDITED BY GEMINI --- */
    }
</style>
</head>
<body>

<!-- Top content group -->
<div class="top-group">
    <!-- Updated title structure -->
    <div class="data-title-container">
        <!-- This text will be updated by the script -->
        <!-- Set initial text to Level 1 (which is now at the bottom) -->
        <span class="title-en">Data collection:</span>
        <span class="title-ua">–ø—Ä–æ—Ü–µ—Å –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö</span>
    </div>

    <!-- --- MODIFIED: New hint text with spans for arrows --- -->
    <p class="scroller-hint">
        <i>
            <span class="arrow-left">‚Ü∂</span>
            –º–æ–∂–Ω–∞ –ø–æ—Ç—è–≥–Ω—É—Ç–∏ –Ω–∞ —ñ–Ω—à–∏–π –±—ñ–∫ –µ–∫—Ä–∞–Ω—É
            <span class="arrow-right">‚Ü∑</span>
        </i>
    </p>
</div>

<!-- New wrapper for scroller and content -->
<div class="main-content-wrapper">
    <!-- Scroller is now here -->
    <!-- Its position is controlled by position:absolute -->
    <div class="scroller-container">
        <!-- ADDED: 6 segments for the 6 gaps between 7 dots -->
        <div class="thick-segment" id="segment-0"></div>
        <div class="thick-segment" id="segment-1"></div>
        <div class="thick-segment" id="segment-2"></div>
        <div class="thick-segment" id="segment-3"></div>
        <div class="thick-segment" id="segment-4"></div>
        <div class="thick-segment" id="segment-5"></div>

        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <!-- REMOVED: #thick-line-segment -->
        <div id="scroller-handle"></div>
    </div>

    <!-- Dashed box is now here -->
    <!-- Its position is fixed by its own margins -->
    <div class="working-area"></div>
</div>


<!-- --- START: EDITED BY GEMINI --- -->
<!-- Wrapper for all bottom content, pushed to the bottom by flexbox -->
<div class="bottom-content-wrapper">
    <!-- PDF Download Link -->
    <div class="pdf-download-container">
        <p id="pdf-download-link">üëâ PDF –∑—ñ –∑–≥–∞–¥–∞–Ω–∏–º–∏ —Ä–µ—Å—É—Ä—Å–∞–º–∏ üëà</p>
    </div>
    
    <!-- Contact Link -->
    <div class="contact-link-container">
        <a id="contact-link" href="mailto:british_idler@knu.ua">‚úâ –ó–∫–æ–Ω—Ç–∞–∫—Ç—É–≤–∞—Ç–∏ —É —Ä–∞–∑—ñ –ø–∏—Ç–∞–Ω—å ‚úâ</a>
    </div>

    <!-- Logo content -->
    <div class="logo-container">
        <div class="logo-item">
            <p class="logo-label">–ö–æ–º–ø'—é—Ç–µ—Ä</p>
            <a href="https://ollama.com" target="_blank" class="logo-link">
                <img src="https://gitknu.github.io/gpt/files/ollama.png" alt="Ollama Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=Ollama';">
            </a>
        </div>
        <div class="logo-item">
            <p class="logo-label">–°–º–∞—Ä—Ç—Ñ–æ–Ω</p>
            <a href="https://play.google.com/store/apps/details?id=com.pocketpalai" target="_blank" class="logo-link" id="pocketpal-link">
                <img src="https://gitknu.github.io/gpt/files/pocketpal.png" alt="PocketPal Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=PocketPal';">
            </a>
        </div>
        <div class="logo-item">
            <p class="logo-label">–í–ª–∞—Å–Ω–∞ –ê–Ü</p>
            <a href="https://github.com/theaniketgiri/create-llm" target="_blank" class="logo-link">
                <img src="https://gitknu.github.io/gpt/files/github.png" alt="GitHub Logo" class="logo" onerror="this.onerror=null; this.src='https://placehold.co/150x150/eeeeee/aaaaaa?text=GitHub';">
            </a>
        </div>
        <div class="logo-item">
            <p class="logo-label">–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü—ñ—è</p>
            <a href="https://docs.google.com/presentation/d/1BeKq7OG8GddcbANK4Xvq0-6F1NqYNmRO8WP4aOt2S0M/edit?usp=sharing" target="_blank" class="logo-link">
                <img src="https://cdn-icons-png.flaticon.com/512/104/104120.png" alt="Presentation Icon" class="logo">
            </a>
        </div>
    </div>
</div>
<!-- --- END: EDITED BY GEMINI --- -->


<script>
    document.addEventListener("DOMContentLoaded", function() {
        // --- START: EDITED BY GEMINI (PDF Generation Logic) ---
        const pdfLink = document.getElementById('pdf-download-link');
        if (pdfLink) {
            pdfLink.addEventListener('click', function() {
                // Ensure the jsPDF library from the CDN is loaded
                if (window.jspdf) {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    // Set font for the title in Ukrainian - Font size is now doubled.
                    doc.setFont("helvetica", "bold");
                    doc.setFontSize(30); // Increased from 16 to 32
                    doc.text("PO3KA3AHO", 105, 30, null, null, "center"); // Adjusted Y position

                    // Set font for the links - Font size is now doubled.
                    doc.setFont("helvetica", "normal");
                    doc.setFontSize(20); // Increased from 12 to 24
                    
                    let yPosition = 70; // Adjusted starting Y position for the first link
                    const yIncrement = 20; // Increased spacing between lines
                    const bulletX = 20;
                    const linkX = 28;

                    const links = [
                        { text: 'aistudio.google.com', url: 'https://aistudio.google.com/prompts/new_chat' },
                        { text: 'notebooklm.google.com', url: 'https://notebooklm.google.com/notebook' },
                        { text: 'podcast.adobe.com', url: 'https://podcast.adobe.com/en/enhance' },
                        { text: 'hf.co/spaces', url: 'https://hf.co/spaces/ResembleAI/resemble-enhance' },
                        { text: 'ai.google.dev/gemma', url: 'https://ai.google.dev/gemma' },
                        { text: 'github.com/QwenLM', url: 'https://github.com/QwenLM' },
                        { text: 'youtube.com', url: 'https://www.youtube.com/shorts/FJtFZwbvkI4' }
                    ];

                    links.forEach(link => {
                        // Set color to black for the bullet point
                        doc.setTextColor(0, 0, 0);
                        doc.text('‚Ä¢', bulletX, yPosition);

                        // Set color to blue for the clickable link
                        doc.setTextColor(0, 0, 255);
                        doc.textWithLink(link.text, linkX, yPosition, { url: link.url });
                        
                        yPosition += yIncrement;
                    });

                    // Save the generated PDF
                    doc.save('gpt_presentation_resources.pdf');
                } else {
                    console.error("jsPDF library not loaded.");
                    alert("Could not generate PDF. The required library was not found.");
                }
            });
        }
        // --- END: EDITED BY GEMINI ---


        // --- START: PocketPal Link Logic ---
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const pocketpalLink = document.getElementById("pocketpal-link");

        // Check for iOS/iPadOS
        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            pocketpalLink.href = "https://apps.apple.com/us/app/pocketpal-ai/id6502579498";
        }
        // Check for MacOS
        else if (/Macintosh|MacIntel|MacPPC|Mac68K/.test(userAgent)) {
            pocketpalLink.href = "https://apps.apple.com/us/app/pocketpal-ai/id6502579498";
        }
        // --- END: PocketPal Link Logic ---

        const scrollerContainer = document.querySelector('.scroller-container');
        const mainContentWrapper = document.querySelector('.main-content-wrapper');
        const topGroup = document.querySelector('.top-group');


        // --- START: Text Data for Scroller (INVERTED) ---
        const levelData = [
            // Index 0 (Top Dot) is now Level 7
            { en: "RLHF:", ua: "–Ω–∞–≤—á–∞–Ω–Ω—è –ø–æ –≤—ñ–¥–≥—É–∫–∞—Ö" },
            { en: "Reward model training:", ua: "—Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –º–æ–¥–µ–ª—ñ –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏" },
            { en: "Supervised finetuning:", ua: "–¥–æ–Ω–∞–≤—á–∞–Ω–Ω—è (–∑—ñ –≤—á–∏—Ç–µ–ª–µ–º)" },
            { en: "Unsupervised pretraining:", ua: "–ø–æ–ø–µ—Ä–µ–¥–Ω—î –Ω–∞–≤—á–∞–Ω–Ω—è (–±–µ–∑ –≤—á–∏—Ç–µ–ª—è)" },
            { en: "Tokenization:", ua: "—Ä–æ–∑–±–∏—Ç—Ç—è –Ω–∞ —Ç–æ–∫–µ–Ω–∏" },
            { en: "Preprocessing:", ua: "–ø–æ–ø–µ—Ä–µ–¥–Ω—è –æ–±—Ä–æ–±–∫–∞" },
            // Index 6 (Bottom Dot) is now Level 1
            { en: "Data collection:", ua: "–ø—Ä–æ—Ü–µ—Å –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö" }
        ];

        const titleEn = document.querySelector('.title-en');
        const titleUa = document.querySelector('.title-ua');
        // Set initial level index to 6 (Bottom dot, which is now Level 1)
        let currentLevelIndex = 6; // Keep track of the current level
        let previousLevelIndex = 6; // --- ADDED: Keep track of previous dot
        // --- END: Text Data for Scroller ---


        // --- START: Scroller Logic ---
        const handle = document.getElementById('scroller-handle');
        const scroller = handle.parentElement; // This is the scroller-container
        const dots = Array.from(scroller.getElementsByClassName('dot'));
        // --- ADDED: Get all segments ---
        const segments = Array.from(scroller.getElementsByClassName('thick-segment'));
        // --- REMOVED: thickLine ---
        let isDragging = false;
        let flowTimer; // --- ADDED: Timer for flow animation

        // --- NEW DRAG LOGIC VARS ---
        let startX = 0;
        let startY = 0;
        let dragMode = 'none'; // 'none', 'pending', 'vertical', 'horizontal'
        // --- END NEW VARS ---

        const dotPositions = dots.map(dot => dot.offsetTop + dot.offsetHeight / 2);

        // --- START: Added by Gemini (Visualization Vars) ---
        let isVisRunning = false;
        const workingArea = document.querySelector('.working-area');
        // --- END: Added by Gemini ---


        // Set initial position of the handle to the *last* dot (bottom)
        handle.style.top = `${dotPositions[dotPositions.length - 1]}px`;

        // --- START: Visualization Functions ---
        
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function addToVisLog(logArea, message) {
            if (!logArea) return;
            const entry = document.createElement('div');
            entry.className = 'vis-log-entry';
            entry.textContent = `> ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function clearVisualization() {
            workingArea.innerHTML = '';
            isVisRunning = false;
        }

        // --- Data Collection Visualizer ---
        async function startDataCollectionVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const sitesToScrape = [
                { id: "site-1", url: "news.com" },
                { id: "site-2", url: "reviews.com" },
                { id: "site-3", url: "blog.org" },
                { id: "site-4", url: "shop.net" }
            ];

            workingArea.innerHTML = `
                <div class="data-vis-container">
                    <div class="vis-main-area" id="vis-main-area">
                        <div class="vis-sources-row">
                            ${sitesToScrape.map(site => `
                                <div class="vis-source pending" id="${site.id}">
                                    <div class="vis-source-icon">üåê</div>
                                    <div class="vis-source-url">${site.url}</div>
                                </div>`).join('')}
                        </div>
                        <div id="vis-scraper-container"><div class="vis-scraper-icon">üï∑Ô∏è</div></div>
                        <div id="vis-storage-container"><div class="vis-storage-icon">üóÑÔ∏è</div></div>
                    </div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;

            const logArea = document.getElementById('vis-log');
            const mainArea = document.getElementById('vis-main-area');
            const scraperContainer = document.getElementById('vis-scraper-container');
            const storageContainer = document.getElementById('vis-storage-container');
            const visContainer = workingArea.querySelector('.data-vis-container');
            
            while (isVisRunning) {
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ –∑–∞–¥–∞—á—É –∑–±–æ—Ä—É –¥–∞–Ω–∏—Ö...");
                await wait(1000);

                for (const site of sitesToScrape) {
                    if (!isVisRunning) break; 

                    const sourceElement = document.getElementById(site.id);
                    sourceElement.classList.remove('pending');
                    sourceElement.classList.add('active');
                    addToVisLog(logArea, `–ü—ñ–¥–∫–ª—é—á–∞—î–º–æ—Å—å –¥–æ ${site.url}...`);
                    
                    const packet = document.createElement('div');
                    packet.className = 'vis-data-packet';
                    packet.innerHTML = 'üìÑ';
                    mainArea.appendChild(packet);
                    
                    const sourceRect = sourceElement.getBoundingClientRect();
                    const scraperRect = scraperContainer.getBoundingClientRect();
                    const storageRect = storageContainer.getBoundingClientRect();
                    const mainAreaRect = mainArea.getBoundingClientRect();
                    const startTop = sourceRect.top - mainAreaRect.top + (sourceRect.height / 2);
                    const startLeft = sourceRect.left - mainAreaRect.left + (sourceRect.width / 2);
                    const midTop = scraperRect.top - mainAreaRect.top + (scraperRect.height / 2);
                    const midLeft = scraperRect.left - mainAreaRect.left + (scraperRect.width / 2);
                    const endTop = storageRect.top - mainAreaRect.top + (storageRect.height / 2);
                    const endLeft = storageRect.left - mainAreaRect.left + (storageRect.width / 2);
                    packet.style.top = `${startTop}px`;
                    packet.style.left = `${startLeft}px`;
                    packet.style.transform = 'translate(-50%, -50%) scale(0.5)';
                    await wait(50);
                    if (!isVisRunning) { if (mainArea.contains(packet)) mainArea.removeChild(packet); break; }
                    packet.style.transition = 'top 1s ease-in-out, left 1s ease-in-out, opacity 0.5s, transform 1s ease-in-out';
                    packet.style.opacity = 1;
                    packet.style.transform = 'translate(-50%, -50%) scale(1)';
                    packet.style.top = `${midTop}px`;
                    packet.style.left = `${midLeft}px`;
                    addToVisLog(logArea, `–ó–±–∏—Ä–∞—î–º–æ –¥–∞–Ω—ñ...`);
                    await wait(1100);
                    if (!isVisRunning) { if (mainArea.contains(packet)) mainArea.removeChild(packet); break; }
                    packet.style.transition = 'top 0.8s ease-in, left 0.8s ease-in, opacity 0.8s ease-in, transform 0.8s ease-in';
                    packet.style.opacity = 0;
                    packet.style.transform = 'translate(-50%, -50%) scale(0.2)';
                    packet.style.top = `${endTop}px`;
                    packet.style.left = `${endLeft}px`;
                    addToVisLog(logArea, `–ó–±–µ—Ä—ñ–≥–∞—î–º–æ –∑—ñ–±—Ä–∞–Ω—ñ –¥–∞–Ω—ñ...`);
                    await wait(900);
                    if (mainArea.contains(packet)) mainArea.removeChild(packet);
                    if (!isVisRunning) break; 
                    sourceElement.classList.remove('active');
                    sourceElement.classList.add('done');
                    addToVisLog(logArea, `–ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑ ${site.url}.`);
                    await wait(500);
                    if (!isVisRunning) break;
                }
                if (!isVisRunning) break;
                addToVisLog(logArea, "–ó–±—ñ—Ä –¥–∞–Ω–∏—Ö –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000); 
                if (!isVisRunning) break;
                visContainer.style.transition = 'opacity 0.5s ease-in-out';
                visContainer.style.opacity = 0;
                await wait(500);
                if (!isVisRunning) break;
                const allSources = workingArea.querySelectorAll('.vis-source');
                allSources.forEach(s => { s.classList.remove('done', 'active'); s.classList.add('pending'); });
                logArea.innerHTML = '';
                visContainer.style.opacity = 1;
                await wait(500);
                visContainer.style.transition = '';
            }
        }
        
        // --- Preprocessing Visualizer ---
        async function startPreprocessingVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const processingJobs = [
                {
                    originalFilename: "article.docx",
                    finalFilename: "data_01.txt",
                    initialText: "–û—Å—å –ø—Ä–∏–∫–ª–∞–¥ —Ç–µ–∫—Å—Ç—É,–∑ –ø–æ–º–∏–ª–∫–∞–º–∏.. –º–∏ –±—É–¥–µ–º–æ –≤–∏–ø—Ä–∞–≤–ª—è—Ç–∏ —ó—Ö ,—â–æ–± –ø–æ–∫–∞–∑–∞—Ç–∏ –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥.",
                    fixes: [
                        { find: "—Ç–µ–∫—Å—Ç—É,–∑", replace: "—Ç–µ–∫—Å—Ç—É, –∑", log: "–î–æ–¥–∞—î–º–æ –ø—Ä–æ–±—ñ–ª –ø—ñ—Å–ª—è –∫–æ–º–∏..." },
                        { find: "..", replace: ".", log: "–í–∏–¥–∞–ª—è—î–º–æ –¥—É–±–ª—é—é—á—É –∫—Ä–∞–ø–∫—É..." },
                        { find: "—ó—Ö ,—â–æ–±", replace: "—ó—Ö, —â–æ–±", log: "–í–∏–ø—Ä–∞–≤–ª—è—î–º–æ –ø—Ä–æ–±—ñ–ª –ø–µ—Ä–µ–¥ –∫–æ–º–æ—é..." }
                    ]
                },
                {
                    originalFilename: "unformatted_data",
                    finalFilename: "data_02.txt",
                    initialText: "   –¢—É—Ç –±–∞–≥–∞—Ç–æ –∑–∞–π–≤–∏—Ö –ø—Ä–æ–±—ñ–ª—ñ–≤ —ñ –í–ï–õ–ò–ö–ò–• –ª—ñ—Ç–µ—Ä. –í—Å–µ —Ü–µ —Ç—Ä–µ–±–∞ –≤–∏–ø—Ä–∞–≤–∏—Ç–∏  .",
                    fixes: [
                        { find: "   ", replace: " ", log: "–í–∏–¥–∞–ª—è—î–º–æ –∑–∞–π–≤—ñ –ø—Ä–æ–±—ñ–ª–∏ –Ω–∞ –ø–æ—á–∞—Ç–∫—É..." },
                        { find: "–í–ï–õ–ò–ö–ò–•", replace: "–≤–µ–ª–∏–∫–∏—Ö", log: "–ü—Ä–∏–≤–æ–¥–∏–º–æ —Ç–µ–∫—Å—Ç –¥–æ –Ω–∏–∂–Ω—å–æ–≥–æ —Ä–µ–≥—ñ—Å—Ç—Ä—É..." },
                        { find: "  .", replace: ".", log: "–í–∏–¥–∞–ª—è—î–º–æ –∑–∞–π–≤—ñ –ø—Ä–æ–±—ñ–ª–∏ –≤ –∫—ñ–Ω—Ü—ñ..." }
                    ]
                },
                {
                    originalFilename: "reviews.json",
                    finalFilename: "data_03.txt",
                    initialText: "–¶–µ —Ç–µ–∫—Å—Ç –∑ HTML —Ç–µ–≥–∞–º–∏ <b>–∂–∏—Ä–Ω–∏–π</b> —Ç–∞ <i>–∫—É—Ä—Å–∏–≤</i>. –ü–æ—Ç—Ä—ñ–±–Ω–æ —ó—Ö –≤–∏–¥–∞–ª–∏—Ç–∏.",
                    fixes: [
                        { find: /<b>(.*?)<\/b>/g, replace: "$1", log: "–í–∏–¥–∞–ª—è—î–º–æ —Ç–µ–≥ <b>..." },
                        { find: /<i>(.*?)<\/i>/g, replace: "$1", log: "–í–∏–¥–∞–ª—è—î–º–æ —Ç–µ–≥ <i>..." }
                    ]
                }
            ];

            workingArea.innerHTML = `
                <div class="preprocessing-vis-container" id="preprocessing-vis-container">
                    <div class="vis-text-area" id="vis-text-area"></div>
                    <div id="vis-storage-container"><div class="vis-storage-icon">üóÑÔ∏è</div></div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;
            
            const logArea = document.getElementById('vis-log');
            const textArea = document.getElementById('vis-text-area');
            const visContainer = document.getElementById('preprocessing-vis-container');
            const storageContainer = document.getElementById('vis-storage-container');

            while (isVisRunning) {
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ –ø—Ä–æ—Ü–µ—Å –æ—á–∏—â–µ–Ω–Ω—è —Ç–∞ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Ñ–∞–π–ª—ñ–≤...");
                await wait(1500);
                if (!isVisRunning) break;

                for (const job of processingJobs) {
                    if (!isVisRunning) break;

                    textArea.innerHTML = `<span>${job.initialText}</span>`;
                    textArea.style.transition = 'opacity 0.3s';
                    textArea.style.opacity = 1;
                    addToVisLog(logArea, `–û–±—Ä–æ–±–∫–∞ —Ñ–∞–π–ª—É: ${job.originalFilename}`);
                    await wait(1000);
                    if (!isVisRunning) break;

                    for (const fix of job.fixes) {
                        if (!isVisRunning) break;
                        
                        addToVisLog(logArea, fix.log);
                        
                        let highlightedHtml = textArea.innerHTML.replace(fix.find, `<span class="error-highlight">${typeof fix.find === 'string' ? fix.find : fix.find.source}</span>`);
                        if (textArea.innerHTML !== highlightedHtml) {
                           textArea.innerHTML = highlightedHtml;
                        }
                        await wait(1000);
                        if (!isVisRunning) break;

                        const errorSpan = textArea.querySelector('.error-highlight');
                        if (errorSpan) {
                            errorSpan.classList.add('error-fixing');
                            errorSpan.classList.remove('error-highlight');
                        }
                        await wait(500);
                        if (!isVisRunning) break;

                        let fixedHtml = textArea.innerHTML.replace(/<span class="error-fixing">.*?<\/span>/, `<span class="corrected-text">${fix.replace}</span>`);
                        if(typeof fix.find !== 'string') { 
                           fixedHtml = textArea.innerHTML.replace(/<span class="error-highlight">.*?<\/span>/, `<span class="corrected-text">${fix.replace}</span>`);
                           textArea.innerHTML = `<span>${textArea.textContent.replace(fix.find, fix.replace)}</span>`;
                        } else {
                           textArea.innerHTML = fixedHtml;
                        }

                        await wait(1000);
                        if (!isVisRunning) break;
                        
                        textArea.innerHTML = `<span>${textArea.textContent}</span>`;
                        await wait(500);
                        if (!isVisRunning) break;
                    }
                    if (!isVisRunning) break;

                    addToVisLog(logArea, "–û—á–∏—â–µ–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ñ–∞–π–ª...");
                    textArea.style.opacity = 0.3;
                    await wait(500);
                    if (!isVisRunning) break;
                    
                    const packet = document.createElement('div');
                    packet.className = 'vis-file-packet';
                    packet.innerHTML = `üìÑ<div class="vis-file-packet-name">${job.originalFilename}</div>`;
                    visContainer.appendChild(packet);

                    const textRect = textArea.getBoundingClientRect();
                    const storageRect = storageContainer.getBoundingClientRect();
                    const containerRect = visContainer.getBoundingClientRect();

                    const startTop = textRect.top - containerRect.top + (textRect.height / 2);
                    const startLeft = textRect.left - containerRect.left + (textRect.width / 2);
                    const endTop = storageRect.top - containerRect.top + (storageRect.height / 2);
                    const endLeft = storageRect.left - containerRect.left + (storageRect.width / 2);

                    packet.style.top = `${startTop}px`;
                    packet.style.left = `${startLeft}px`;
                    packet.style.transform = 'translate(-50%, -50%) scale(0.5)';

                    await wait(50);
                    if (!isVisRunning) { if (visContainer.contains(packet)) visContainer.removeChild(packet); break; }
                    
                    packet.style.opacity = 1;
                    packet.style.transform = 'translate(-50%, -50%) scale(1)';
                    packet.style.top = `${endTop}px`;
                    packet.style.left = `${endLeft}px`;

                    await wait(1100);
                    if (!isVisRunning) { if (visContainer.contains(packet)) visContainer.removeChild(packet); break; }

                    addToVisLog(logArea, `–ü–µ—Ä–µ–π–º–µ–Ω–æ–≤—É—î–º–æ –≤ ${job.finalFilename}`);
                    const nameTag = packet.querySelector('.vis-file-packet-name');
                    nameTag.style.backgroundColor = '#ddffdd';
                    nameTag.textContent = job.finalFilename;
                    
                    await wait(1000);
                    if (!isVisRunning) { if (visContainer.contains(packet)) visContainer.removeChild(packet); break; }
                    
                    packet.style.opacity = 0;
                    await wait(500);
                    if (visContainer.contains(packet)) visContainer.removeChild(packet);
                    if (!isVisRunning) break;

                    textArea.innerHTML = '';
                    await wait(500);
                    if (!isVisRunning) break;
                }

                if (!isVisRunning) break;
                addToVisLog(logArea, "–í—Å—ñ —Ñ–∞–π–ª–∏ –æ–±—Ä–æ–±–ª–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000);
                if (!isVisRunning) break;

                visContainer.style.transition = 'opacity 0.5s ease-in-out';
                visContainer.style.opacity = 0;
                await wait(500);
                if (!isVisRunning) break;
                
                logArea.innerHTML = '';
                visContainer.style.opacity = 1;
                await wait(500);
                visContainer.style.transition = '';
            }
        }

        // --- Tokenization Visualizer ---
        async function startTokenizationVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const sentences = [
                "the quick brown fox",
                "jumps over the lazy dog",
                "the lazy fox slept"
            ];

            workingArea.innerHTML = `
                <div class="tokenization-vis-container">
                    <div class="vis-token-main">
                        <div class="vis-sentence-area" id="vis-sentence-area"></div>
                        <div class="vis-vocab-area" id="vis-vocab-area"></div>
                        <div class="vis-sequence-area" id="vis-sequence-area"></div>
                    </div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;

            const logArea = document.getElementById('vis-log');
            const sentenceArea = document.getElementById('vis-sentence-area');
            const vocabArea = document.getElementById('vis-vocab-area');
            const sequenceArea = document.getElementById('vis-sequence-area');
            const visContainer = workingArea.querySelector('.tokenization-vis-container');

            const vocabulary = {};
            let nextTokenId = 1;

            while (isVisRunning) {
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ –ø—Ä–æ—Ü–µ—Å —Ç–æ–∫–µ–Ω—ñ–∑–∞—Ü—ñ—ó...");
                await wait(1500);

                for (const sentence of sentences) {
                    if (!isVisRunning) break;

                    sentenceArea.innerHTML = sentence.split(' ').map(word => `<span class="vis-word-token">${word}</span>`).join('');
                    sequenceArea.innerHTML = ''; 
                    addToVisLog(logArea, `–û–±—Ä–æ–±–∫–∞ —Ä–µ—á–µ–Ω–Ω—è: "${sentence}"`);
                    await wait(2000);
                    if (!isVisRunning) break;

                    const wordTokens = sentenceArea.querySelectorAll('.vis-word-token');
                    addToVisLog(logArea, "–†–æ–∑–±–∏—Ç—Ç—è –Ω–∞ –æ–∫—Ä–µ–º—ñ —Ç–æ–∫–µ–Ω–∏...");
                    wordTokens.forEach(token => token.classList.add('spacing'));
                    await wait(1500);
                    if (!isVisRunning) break;

                    const currentSequence = [];
                    for (const token of wordTokens) {
                        if (!isVisRunning) break;
                        const word = token.textContent.toLowerCase();
                        token.classList.add('highlight');
                        
                        if (!vocabulary[word]) {
                            addToVisLog(logArea, `–ù–æ–≤–∏–π —Ç–æ–∫–µ–Ω '${word}'. –ü—Ä–∏—Å–≤–æ—î–Ω–Ω—è ID: ${nextTokenId}`);
                            vocabulary[word] = nextTokenId;
                            
                            const vocabEntry = document.createElement('div');
                            vocabEntry.className = 'vis-vocab-entry';
                            vocabEntry.id = `vocab-${word}`;
                            vocabEntry.innerHTML = `<span class="vis-vocab-id">${nextTokenId}:</span><span>${word}</span>`;
                            vocabArea.appendChild(vocabEntry);
                            await wait(50);
                            vocabEntry.classList.add('visible');

                            nextTokenId++;
                        } else {
                             addToVisLog(logArea, `–¢–æ–∫–µ–Ω '${word}' –≤–∂–µ —ñ—Å–Ω—É—î. ID: ${vocabulary[word]}`);
                             const existingEntry = document.getElementById(`vocab-${word}`);
                             if (existingEntry) {
                                 existingEntry.classList.add('highlight');
                             }
                        }
                        
                        currentSequence.push(vocabulary[word]);
                        sequenceArea.innerHTML = `[ ${currentSequence.join(', ')} ]`;

                        await wait(1500);
                        if (!isVisRunning) break;

                        token.classList.remove('highlight');
                        const existingEntry = document.getElementById(`vocab-${word}`);
                        if (existingEntry) {
                            existingEntry.classList.remove('highlight');
                        }
                        await wait(500);
                    }
                    if (!isVisRunning) break;
                    
                    addToVisLog(logArea, "–†–µ—á–µ–Ω–Ω—è —É—Å–ø—ñ—à–Ω–æ —Ç–æ–∫–µ–Ω—ñ–∑–æ–≤–∞–Ω–æ.");
                    await wait(2500);
                    if (!isVisRunning) break;
                }

                if (!isVisRunning) break;
                addToVisLog(logArea, "–í—Å—ñ —Ä–µ—á–µ–Ω–Ω—è –æ–±—Ä–æ–±–ª–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000);
                if (!isVisRunning) break;

                visContainer.style.transition = 'opacity 0.5s ease-in-out';
                visContainer.style.opacity = 0;
                await wait(500);
                if (!isVisRunning) break;
                
                logArea.innerHTML = '';
                sentenceArea.innerHTML = '';
                vocabArea.innerHTML = '';
                sequenceArea.innerHTML = '';
                Object.keys(vocabulary).forEach(key => delete vocabulary[key]);
                nextTokenId = 1;
                
                visContainer.style.opacity = 1;
                await wait(500);
                visContainer.style.transition = '';
            }
        }
        
        // --- Unsupervised Pretraining Visualizer ---
        async function startUnsupervisedPretrainingVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const corpus = "a cat sat on the mat a dog ran by";
            const unique_tokens = [...new Set(corpus.split(' '))].sort();
            const token_pairs = unique_tokens.flatMap((t1, i) => unique_tokens.slice(i + 1).map(t2 => [t1, t2].sort().join('-'))).filter((v, i, a) => a.indexOf(v) === i);

            workingArea.innerHTML = `
                <div class="pretraining-vis-container">
                    <!-- Phase 1: Connection Building -->
                    <div class="pretraining-phase" id="phase-1-connections">
                        <div class="vis-corpus-analysis-area">
                            <div class="vis-corpus-text-area" id="vis-corpus-text-area"></div>
                            <div class="vis-weight-matrix-area" id="vis-weight-matrix-area"></div>
                        </div>
                    </div>

                    <!-- Phase 2: Masked Prediction -->
                    <div class="pretraining-phase hidden" id="phase-2-prediction">
                        <div class="vis-prediction-area">
                            <div class="vis-model-area">
                                <div class="vis-model-icon">üß†</div>
                                <div class="vis-knowledge-gears">
                                    <span class="gear1">‚öôÔ∏è</span>
                                    <span class="gear2">‚öôÔ∏è</span>
                                </div>
                            </div>
                            <div class="vis-text-processing-area" id="vis-text-processing-area"></div>
                             <div class="vis-stats-area">
                                <div>Epoch: <span id="stat-epoch">1</span></div>
                                <div>Loss: <span id="stat-loss">0.87</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="vis-log" id="vis-log"></div>
                </div>`;

            const logArea = document.getElementById('vis-log');
            const phase1Container = document.getElementById('phase-1-connections');
            const phase2Container = document.getElementById('phase-2-prediction');
            const corpusTextArea = document.getElementById('vis-corpus-text-area');
            const weightMatrixArea = document.getElementById('vis-weight-matrix-area');
            
            // --- PHASE 1: Build Connections ---
            const corpusWords = corpus.split(' ');
            corpusTextArea.innerHTML = corpusWords.map((word, index) => `<span class="vis-corpus-word" id="cword-${index}">${word}</span>`).join(' ');
            const wordElements = corpusWords.map((_, index) => document.getElementById(`cword-${index}`));
            
            weightMatrixArea.style.gridTemplateColumns = `repeat(${Math.min(unique_tokens.length, 6)}, 1fr)`;
            const weights = {};
            for (const pair of token_pairs) {
                const [t1, t2] = pair.split('-');
                weights[pair] = 0;
                const cell = document.createElement('div');
                cell.className = 'vis-weight-cell';
                cell.id = `cell-${pair}`;
                cell.innerHTML = `<div class="token-pair">${t1}‚Üî${t2}</div><div class="weight-value" id="weight-${pair}">0</div>`;
                weightMatrixArea.appendChild(cell);
            }

            addToVisLog(logArea, "–ê–Ω–∞–ª—ñ–∑ —Ç–µ–∫—Å—Ç—É –¥–ª—è –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—è –∑–≤'—è–∑–∫—ñ–≤ –º—ñ–∂ —Ç–æ–∫–µ–Ω–∞–º–∏...");
            await wait(1500);
            
            const scanWindowContainer = document.createElement('div');
            corpusTextArea.appendChild(scanWindowContainer);

            const windowSize = 3; 
            for (let i = 0; i <= corpusWords.length - windowSize; i++) {
                if (!isVisRunning) return;
                
                scanWindowContainer.innerHTML = '';

                const windowWords = corpusWords.slice(i, i + windowSize);
                const windowWordEls = wordElements.slice(i, i + windowSize);
                
                const wordsByLine = {};
                windowWordEls.forEach(el => {
                    const top = el.offsetTop;
                    if (!wordsByLine[top]) {
                        wordsByLine[top] = [];
                    }
                    wordsByLine[top].push(el);
                });

                for (const top in wordsByLine) {
                    const lineWords = wordsByLine[top];
                    const firstElOnLine = lineWords[0];
                    const lastElOnLine = lineWords[lineWords.length - 1];
                    
                    const scanWindow = document.createElement('div');
                    scanWindow.className = 'vis-scan-window';
                    scanWindowContainer.appendChild(scanWindow);

                    scanWindow.style.left = `${firstElOnLine.offsetLeft}px`;
                    scanWindow.style.top = `${firstElOnLine.offsetTop}px`;
                    scanWindow.style.width = `${lastElOnLine.offsetLeft + lastElOnLine.offsetWidth - firstElOnLine.offsetLeft}px`;
                    scanWindow.style.height = `${firstElOnLine.offsetHeight}px`;
                }

                addToVisLog(logArea, `–°–∫–∞–Ω—É–≤–∞–Ω–Ω—è: [${windowWords.join(' ')}]`);
                await wait(1000);
                
                for(let j = 0; j < windowWords.length; j++) {
                    for (let k = j + 1; k < windowWords.length; k++) {
                        if (!isVisRunning) return;
                        
                        wordElements.forEach(el => el.classList.remove('active-pair'));
                        windowWordEls[j].classList.add('active-pair');
                        windowWordEls[k].classList.add('active-pair');
                        
                        const token1 = windowWords[j];
                        const token2 = windowWords[k];
                        const pairKey = [token1, token2].sort().join('-');
                        
                        if (weights.hasOwnProperty(pairKey)) {
                            weights[pairKey]++;
                            const cellEl = document.getElementById(`cell-${pairKey}`);
                            const weightEl = document.getElementById(`weight-${pairKey}`);
                            
                            addToVisLog(logArea, `–ó–≤'—è–∑–æ–∫: ${token1} ‚Üî ${token2}. –í–∞–≥–∞: ${weights[pairKey]}`);
                            cellEl.classList.add('highlight-update');
                            weightEl.textContent = weights[pairKey];
                            
                            await wait(750);
                            cellEl.classList.remove('highlight-update');
                        }
                    }
                }
                 wordElements.forEach(el => el.classList.remove('active-pair'));
                 await wait(500);
            }
            scanWindowContainer.style.opacity = 0;


            // --- Transition to Phase 2 ---
            addToVisLog(logArea, "–ü–æ–±—É–¥–æ–≤–∞–Ω–æ –∫–∞—Ä—Ç—É –∑–≤'—è–∑–∫—ñ–≤. –ü–æ—á–∏–Ω–∞—î–º–æ —Ç—Ä–µ–Ω—É–≤–∞–Ω–Ω—è.");
            await wait(2000);
            if (!isVisRunning) return;
            
            phase1Container.style.opacity = 0;
            phase2Container.classList.remove('hidden');
            await wait(50);
            // EDITED: Don't move the weight matrix, just fade it out
            weightMatrixArea.style.transition = 'opacity 0.5s ease-in-out';
            weightMatrixArea.style.opacity = '0.1'; // Fade to background
            phase2Container.style.opacity = 1;
            
            await wait(500);
            phase1Container.style.display = 'none';
            

            // --- PHASE 2: Masked Prediction Loop ---
            const sentences = [ // EDITED: Sentences from the new corpus
                { text: "a cat sat on the", mask: 1, alternatives: ["dog", "mat"] },
                { text: "sat on the mat", mask: 2, alternatives: ["cat", "dog"] },
                { text: "a dog ran by", mask: 1, alternatives: ["cat", "mat"] }
            ];
            const textArea = document.getElementById('vis-text-processing-area');
            const epochStat = document.getElementById('stat-epoch');
            const lossStat = document.getElementById('stat-loss');
            
            let epoch = 1;
            let loss = 0.87;

            while(isVisRunning) {
                epochStat.textContent = epoch;
                lossStat.textContent = loss.toFixed(2);
                addToVisLog(logArea, `–ü–æ—á–∏–Ω–∞—î–º–æ –ï–ø–æ—Ö—É ${epoch}. –†—ñ–≤–µ–Ω—å –ø–æ–º–∏–ª–∫–∏: ${loss.toFixed(2)}`);
                await wait(1500);

                for(const sentenceData of sentences) {
                    if (!isVisRunning) break;

                    const words = sentenceData.text.split(' ');
                    const correctWord = words[sentenceData.mask];

                    addToVisLog(logArea, "–ê–Ω–∞–ª—ñ–∑—É—î–º–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ç–µ–∫—Å—Ç...");
                    textArea.innerHTML = words.join(' ');
                    await wait(1500);
                    if (!isVisRunning) break;

                    addToVisLog(logArea, `–ü—Ä–∏—Ö–æ–≤—É—î–º–æ —Å–ª–æ–≤–æ –¥–ª—è —Ç—Ä–µ–Ω—É–≤–∞–Ω–Ω—è.`);
                    const contextWords = words.filter((_, idx) => idx !== sentenceData.mask);
                    words[sentenceData.mask] = `<span class="vis-masked-word">[MASK]<div class="vis-prediction-popup"></div></span>`;
                    textArea.innerHTML = words.join(' ');
                    await wait(1500);
                    if (!isVisRunning) break;
                    
                    const maskedElement = textArea.querySelector('.vis-masked-word');
                    const popup = maskedElement.querySelector('.vis-prediction-popup');
                    addToVisLog(logArea, "–ú–æ–¥–µ–ª—å –Ω–∞–º–∞–≥–∞—î—Ç—å—Å—è –≤–≥–∞–¥–∞—Ç–∏ —Å–ª–æ–≤–æ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ –≤–∞–≥–∏...");

                    const activeCells = [];
                    for(const cword of contextWords) {
                         for (const token of unique_tokens) {
                            const pairKey = [cword, token].sort().join('-');
                            if(weights.hasOwnProperty(pairKey)) {
                                const cell = document.getElementById(`cell-${pairKey}`);
                                cell.classList.add('highlight-predict');
                                activeCells.push(cell);
                            }
                         }
                    }

                    await wait(2000);
                    if (!isVisRunning) break;
                    activeCells.forEach(cell => cell.classList.remove('highlight-predict'));

                    const isCorrect = Math.random() > loss;
                    if (!isCorrect) {
                        const wrongWord = sentenceData.alternatives[Math.floor(Math.random() * sentenceData.alternatives.length)];
                        popup.textContent = `üîÆ ${wrongWord}?`;
                        popup.classList.add('incorrect', 'visible');
                        addToVisLog(logArea, `–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ: "${wrongWord}". –û–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–∞–≥—ñ–≤...`);
                        await wait(2000);
                        if (!isVisRunning) break;
                        popup.classList.remove('visible');
                        await wait(300);
                    }

                    popup.textContent = `‚úÖ ${correctWord}!`;
                    popup.classList.remove('incorrect');
                    popup.classList.add('correct', 'visible');
                    addToVisLog(logArea, `–ü—Ä–∞–≤–∏–ª—å–Ω–æ: "${correctWord}"!`);
                    await wait(2000);
                    if (!isVisRunning) break;

                    textArea.innerHTML = sentenceData.text;
                    await wait(1000);
                }

                if (!isVisRunning) break;
                epoch++;
                loss *= 0.65; 
                if (loss < 0.1) {
                     addToVisLog(logArea, "–ù–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                     await wait(2000);
                     if (!isVisRunning) break;
                     startUnsupervisedPretrainingVisualization(); 
                     return;
                } else {
                     addToVisLog(logArea, "–ï–ø–æ—Ö–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ó–Ω–∏–∂–µ–Ω–Ω—è —Ä—ñ–≤–Ω—è –ø–æ–º–∏–ª–∫–∏...");
                     await wait(2000);
                }
            }
        }

        // --- Supervised Finetuning Visualizer ---
        async function startSupervisedFinetuningVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const qaPairs = [
                { prompt: "–°—Ç–æ–ª–∏—Ü—è –£–∫—Ä–∞—ó–Ω–∏?", initial: "–õ—å–≤—ñ–≤", target: "–ö–∏—ó–≤" },
                { prompt: "–°–∫—ñ–ª—å–∫–∏ –±—É–¥–µ 2 + 2?", initial: "3", target: "4" },
                { prompt: "–¢—Ä–µ—Ç—è –ø–ª–∞–Ω–µ—Ç–∞ –≤—ñ–¥ –°–æ–Ω—Ü—è?", initial: "–ú–∞—Ä—Å", target: "–ó–µ–º–ª—è" },
                { prompt: "–Ø–∫–∏–π –∫–æ–ª—ñ—Ä —É –Ω–µ–±–∞?", initial: "–ó–µ–ª–µ–Ω–∏–π", target: "–°–∏–Ω—ñ–π" }
            ];

            workingArea.innerHTML = `
                <div class="finetuning-vis-container">
                    <div class="vis-qa-dataset-area" id="vis-qa-dataset-area">
                        <strong>–ù–∞–±—ñ—Ä –¥–∞–Ω–∏—Ö (Q&A):</strong>
                        <div class="vis-qa-dataset-list" id="vis-qa-dataset-list">
                         ${qaPairs.map(p => `<div class="vis-qa-pair-item"><span>Q:</span> ${p.prompt} <br><span>A:</span> ${p.target}</div>`).join('')}
                        </div>
                    </div>

                    <div class="vis-finetuning-main" id="vis-finetuning-main" style="opacity: 0;">
                        <div class="vis-qa-area">
                            <div class="vis-prompt-box">
                                <strong>–ó–∞–ø–∏—Ç:</strong>
                                <div id="vis-prompt-text"></div>
                            </div>
                            <div class="vis-response-comparison">
                                <div class="vis-response-box" id="vis-model-response-box">
                                    <strong>–í—ñ–¥–ø–æ–≤—ñ–¥—å –º–æ–¥–µ–ª—ñ:</strong>
                                    <div id="vis-model-response-text"></div>
                                </div>
                                <div class="vis-response-box" id="vis-target-response-box">
                                    <strong>–ü—Ä–∞–≤–∏–ª—å–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å:</strong>
                                    <div id="vis-target-response-text"></div>
                                </div>
                            </div>
                        </div>
                        <div class="vis-model-area-ft">
                            <div class="vis-model-icon">üß†</div>
                            <div class="vis-update-arrow" id="vis-update-arrow">‚¨áÔ∏è</div>
                        </div>
                    </div>
                     <div class="vis-stats-area">
                        <div>Epoch: <span id="stat-epoch-ft">1</span></div>
                        <div>Loss: <span id="stat-loss-ft">0.75</span></div>
                    </div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;
            
            const logArea = document.getElementById('vis-log');
            const qaDatasetArea = document.getElementById('vis-qa-dataset-area');
            const finetuningMain = document.getElementById('vis-finetuning-main');
            const qaPairItems = Array.from(workingArea.querySelectorAll('.vis-qa-pair-item'));
            const promptText = document.getElementById('vis-prompt-text');
            const modelResponseText = document.getElementById('vis-model-response-text');
            const targetResponseText = document.getElementById('vis-target-response-text');
            const modelResponseBox = document.getElementById('vis-model-response-box');
            const targetResponseBox = document.getElementById('vis-target-response-box');
            const updateArrow = document.getElementById('vis-update-arrow');
            const epochStat = document.getElementById('stat-epoch-ft');
            const lossStat = document.getElementById('stat-loss-ft');
            
            addToVisLog(logArea, `–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –Ω–∞–±–æ—Ä—É –¥–∞–Ω–∏—Ö –¥–ª—è –¥–æ–Ω–∞–≤—á–∞–Ω–Ω—è...`);
            await wait(1500);

            // EDITED: Animate feeding instead of showing a long list
            for(const item of qaPairItems) {
                if (!isVisRunning) return;
                item.classList.add('feeding');
                await wait(400);
            }

            addToVisLog(logArea, `–ù–∞–±—ñ—Ä –¥–∞–Ω–∏—Ö –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –≤ –º–æ–¥–µ–ª—å.`);
            await wait(1000);
            if (!isVisRunning) return;

            qaDatasetArea.style.opacity = '0';
            qaDatasetArea.style.transform = 'translate(-50%, -50%) scale(0.8)';
            finetuningMain.style.opacity = '1';
            await wait(500);
            qaDatasetArea.style.display = 'none';

            let epoch = 1;
            let loss = 0.75; // Start with a higher chance of being wrong

            while(isVisRunning) {
                epochStat.textContent = epoch;
                lossStat.textContent = loss.toFixed(2);
                addToVisLog(logArea, `–ü–æ—á–∏–Ω–∞—î–º–æ –ï–ø–æ—Ö—É ${epoch} –¥–æ–Ω–∞–≤—á–∞–Ω–Ω—è. –†—ñ–≤–µ–Ω—å –ø–æ–º–∏–ª–∫–∏: ${loss.toFixed(2)}`);
                await wait(1500);

                for (const pair of qaPairs) {
                    if (!isVisRunning) break;

                    // Reset state
                    promptText.textContent = '';
                    modelResponseText.textContent = '';
                    targetResponseText.textContent = '';
                    modelResponseBox.classList.remove('incorrect', 'correct');
                    targetResponseBox.classList.remove('incorrect', 'correct');
                    updateArrow.classList.remove('visible');
                    
                    // Show prompt
                    promptText.textContent = pair.prompt;
                    addToVisLog(logArea, `–ó–∞–ø–∏—Ç: "${pair.prompt}"`);
                    await wait(1500);
                    if (!isVisRunning) break;
                    
                    // --- MODIFIED LOGIC: Model can be right or wrong based on loss ---
                    const isInitiallyWrong = Math.random() < loss;

                    if (isInitiallyWrong) {
                        // Model gives initial (wrong) answer
                        modelResponseText.textContent = pair.initial;
                        addToVisLog(logArea, `–í—ñ–¥–ø–æ–≤—ñ–¥—å –º–æ–¥–µ–ª—ñ (–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞): "${pair.initial}"`);
                        await wait(1500);
                        if (!isVisRunning) break;

                        // Show target answer and compare
                        targetResponseText.textContent = pair.target;
                        modelResponseBox.classList.add('incorrect');
                        targetResponseBox.classList.add('correct');
                        addToVisLog(logArea, `–ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∑ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—é –≤—ñ–¥–ø–æ–≤—ñ–¥–¥—é: "${pair.target}"`);
                        await wait(1000);
                        if (!isVisRunning) break;

                        // Show update arrow and log correction
                        updateArrow.classList.add('visible');
                        addToVisLog(logArea, `–ü–æ–º–∏–ª–∫–∞! –ö–æ—Ä–∏–≥—É—î–º–æ –≤–∞–≥–∏ –º–æ–¥–µ–ª—ñ...`);
                        await wait(1500);
                        if (!isVisRunning) break;

                        // Animate the text correction
                        modelResponseText.innerHTML = `<span class="text-correction">${pair.initial}</span> <span class="text-corrected">${pair.target}</span>`;
                        modelResponseBox.classList.remove('incorrect');
                        modelResponseBox.classList.add('correct');
                        updateArrow.classList.remove('visible');
                        addToVisLog(logArea, `–í–∞–≥–∏ –æ–Ω–æ–≤–ª–µ–Ω–æ. –ú–æ–¥–µ–ª—å –≤–∏–≤—á–∏–ª–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å.`);
                        await wait(2500);
                        if (!isVisRunning) break;
                    } else {
                        // Model gives correct answer
                        modelResponseText.textContent = pair.target;
                        modelResponseBox.classList.add('correct');
                        addToVisLog(logArea, `–í—ñ–¥–ø–æ–≤—ñ–¥—å –º–æ–¥–µ–ª—ñ (–ø—Ä–∞–≤–∏–ª—å–Ω–∞): "${pair.target}"`);
                        await wait(1500);
                        if (!isVisRunning) break;

                        addToVisLog(logArea, `–ü—Ä–∞–≤–∏–ª—å–Ω–æ! –í–∞–≥–∏ –ø—ñ–¥—Å–∏–ª—é—é—Ç—å—Å—è.`);
                        await wait(2500);
                        if (!isVisRunning) break;
                    }
                }

                if (!isVisRunning) break;
                epoch++;
                loss *= 0.45; // Decrease loss more significantly per epoch
                 if (loss < 0.05) {
                     addToVisLog(logArea, "–î–æ–Ω–∞–≤—á–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ! –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                     await wait(2000);
                     if (!isVisRunning) break;
                     // Reset and restart the visualization
                     loss = 0.75; 
                     epoch = 1;
                     // We need to re-run the whole function to reset HTML elements properly
                     startSupervisedFinetuningVisualization();
                     return; 
                } else {
                     addToVisLog(logArea, "–ï–ø–æ—Ö–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ó–Ω–∏–∂–µ–Ω–Ω—è —Ä—ñ–≤–Ω—è –ø–æ–º–∏–ª–∫–∏...");
                     await wait(2000);
                }
            }
        }

        // --- Reward Model Training Visualizer ---
        async function startRewardModelTrainingVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;

            const rankingData = [
                {
                    prompt: "–Ø–∫ –Ω–∞–ø–∏—Å–∞—Ç–∏ –µ—Å–µ?",
                    responses: [
                        { text: "–ü–æ—á–Ω—ñ—Ç—å –∑ –ø–ª–∞–Ω—É, –Ω–∞–ø–∏—à—ñ—Ç—å –≤—Å—Ç—É–ø, –æ—Å–Ω–æ–≤–Ω—É —á–∞—Å—Ç–∏–Ω—É —Ç–∞ –≤–∏—Å–Ω–æ–≤–æ–∫.", rank: 1, score: 0.92 },
                        { text: "–ü—Ä–æ—Å—Ç–æ –ø–æ—á–Ω—ñ—Ç—å –ø–∏—Å–∞—Ç–∏ –≤—Å–µ, —â–æ –¥—É–º–∞—î—Ç–µ.", rank: 2, score: 0.15 }
                    ]
                },
                {
                    prompt: "–ü–æ—Ä–∞–¥—å—Ç–µ —Ñ—ñ–ª—å–º –Ω–∞ –≤–µ—á—ñ—Ä.",
                    responses: [
                        { text: "–ó–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –∂–∞–Ω—Ä—É. '–í—Ç–µ—á–∞ –∑ –®–æ—É—à–µ–Ω–∫–∞' - —á—É–¥–æ–≤–∞ –¥—Ä–∞–º–∞.", rank: 1, score: 0.88 },
                        { text: "–î–∏–≤—ñ—Ç—å—Å—è –±—É–¥—å-—â–æ.", rank: 2, score: 0.05 },
                        { text: "–§—ñ–ª—å–º–∏ - —Ü–µ –Ω—É–¥–Ω–æ.", rank: 3, score: -0.5 }
                    ]
                },
                 {
                    prompt: "–Ø–∫ –∑–≤–∞—Ä–∏—Ç–∏ –∫–∞–≤—É?",
                    responses: [
                        { text: "–ù–∞—Å–∏–ø—Ç–µ –∫–∞–≤—É –≤ —á–∞—à–∫—É —ñ –∑–∞–ª–∏–π—Ç–µ –æ–∫—Ä–æ–ø–æ–º.", rank: 2, score: 0.45 },
                        { text: "–í—ñ–∑—å–º—ñ—Ç—å –º–µ–ª–µ–Ω—É –∫–∞–≤—É, –∑–∞–ª–∏–π—Ç–µ –≥–∞—Ä—è—á–æ—é –≤–æ–¥–æ—é —É —Ñ—Ä–µ–Ω—á-–ø—Ä–µ—Å—ñ, –∑–∞—á–µ–∫–∞–π—Ç–µ 4 —Ö–≤–∏–ª–∏–Ω–∏.", rank: 1, score: 0.95 }
                    ]
                }
            ];
            
            workingArea.innerHTML = `
                <div class="reward-model-vis-container">
                    <div class="reward-model-main" id="reward-model-main">
                        <div class="vis-responses-area">
                            <div class="vis-prompt-box">
                                <strong>–ó–∞–ø–∏—Ç:</strong>
                                <div id="vis-prompt-text-rm"></div>
                            </div>
                            <div id="vis-responses-list"></div>
                            <div class="vis-human-ranker" id="vis-human-ranker">ü§î</div>
                        </div>
                        <div class="vis-reward-model-area">
                             <div class="vis-reward-model-icon" id="vis-reward-model-icon">
                                üèÖ
                                <div class="gears">
                                   <span class="gear1">‚öôÔ∏è</span><span class="gear2">‚öôÔ∏è</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;
            
            const logArea = document.getElementById('vis-log');
            const mainArea = document.getElementById('reward-model-main');
            const promptText = document.getElementById('vis-prompt-text-rm');
            const responsesList = document.getElementById('vis-responses-list');
            const humanRanker = document.getElementById('vis-human-ranker');
            const rewardModelIcon = document.getElementById('vis-reward-model-icon');

            while(isVisRunning) {
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ —Ç—Ä–µ–Ω—É–≤–∞–Ω–Ω—è –º–æ–¥–µ–ª—ñ –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏...");
                await wait(1500);

                for (const item of rankingData) {
                    if (!isVisRunning) break;

                    promptText.textContent = item.prompt;
                    responsesList.innerHTML = item.responses.map((r, i) =>
                        `<div class="vis-response-box-rm" id="response-rm-${i}">
                            ${r.text}
                            <div class="vis-reward-score" id="score-rm-${i}"></div>
                         </div>`
                    ).join('');
                    
                    addToVisLog(logArea, `–û—Ç—Ä–∏–º–∞–Ω–æ –∑–∞–ø–∏—Ç: "${item.prompt}"`);
                    await wait(2000);
                    if (!isVisRunning) break;
                    
                    addToVisLog(logArea, "–õ—é–¥–∏–Ω–∞-–æ—Ü—ñ–Ω—é–≤–∞—á –ø–æ—Ä—ñ–≤–Ω—é—î –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ...");
                    const preferredResponseIndex = item.responses.findIndex(r => r.rank === 1);
                    const preferredResponseEl = document.getElementById(`response-rm-${preferredResponseIndex}`);
                    
                    humanRanker.style.opacity = 1;
                    humanRanker.style.top = `${preferredResponseEl.offsetTop + preferredResponseEl.offsetHeight / 2 - humanRanker.offsetHeight / 2}px`;
                    await wait(1000);
                    if (!isVisRunning) break;

                    preferredResponseEl.classList.add('preferred');
                    humanRanker.innerHTML = 'üëç';
                    addToVisLog(logArea, `–ù–∞–π–∫—Ä–∞—â—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å –æ–±—Ä–∞–Ω–æ.`);
                    await wait(1500);
                    if (!isVisRunning) break;

                    const packet = document.createElement('div');
                    packet.className = 'vis-reward-data-packet';
                    packet.innerHTML = 'üó≥Ô∏è';
                    mainArea.appendChild(packet);

                    const rankerRect = humanRanker.getBoundingClientRect();
                    const modelRect = rewardModelIcon.getBoundingClientRect();
                    const mainRect = mainArea.getBoundingClientRect();

                    packet.style.top = `${rankerRect.top - mainRect.top + rankerRect.height/2}px`;
                    packet.style.left = `${rankerRect.left - mainRect.left + rankerRect.width/2}px`;
                    
                    await wait(50);
                    if (!isVisRunning) { if(mainArea.contains(packet)) mainArea.removeChild(packet); break; }
                    
                    packet.style.opacity = 1;
                    packet.style.transform = 'scale(1)';
                    packet.style.top = `${modelRect.top - mainRect.top + modelRect.height/2}px`;
                    packet.style.left = `${modelRect.left - mainRect.left + modelRect.width/2}px`;
                    addToVisLog(logArea, `–í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–µ—Ä–µ–≤–∞–≥–∏ –¥–ª—è —Ç—Ä–µ–Ω—É–≤–∞–Ω–Ω—è –º–æ–¥–µ–ª—ñ...`);
                    
                    await wait(1100);
                    if (!isVisRunning) { if(mainArea.contains(packet)) mainArea.removeChild(packet); break; }
                    
                    rewardModelIcon.classList.add('training');
                    if(mainArea.contains(packet)) mainArea.removeChild(packet);
                    addToVisLog(logArea, `–ú–æ–¥–µ–ª—å –æ–Ω–æ–≤–ª—é—î —Å–≤–æ—ó –≤–∞–≥–∏...`);
                    
                    await wait(2000);
                    if (!isVisRunning) break;
                    rewardModelIcon.classList.remove('training');

                    addToVisLog(logArea, `–ú–æ–¥–µ–ª—å –Ω–∞–≤—á–∏–ª–∞—Å—è –ø—Ä–∏—Å–≤–æ—é–≤–∞—Ç–∏ –±–∞–ª–∏.`);
                    for(let i=0; i < item.responses.length; i++) {
                        const scoreEl = document.getElementById(`score-rm-${i}`);
                        scoreEl.textContent = `üèÜ ${item.responses[i].score}`;
                        scoreEl.classList.add('visible');
                        await wait(300);
                    }
                    
                    await wait(3000);
                    if (!isVisRunning) break;

                    // Cleanup for next iteration
                    responsesList.innerHTML = '';
                    promptText.textContent = '';
                    humanRanker.style.opacity = 0;
                    humanRanker.innerHTML = 'ü§î';
                }

                if (!isVisRunning) break;
                addToVisLog(logArea, "–¶–∏–∫–ª —Ç—Ä–µ–Ω—É–≤–∞–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000);
            }
        }
        
        // --- RLHF Visualizer ---
        async function startRLHFVisualization() {
            if (isVisRunning) return;
            isVisRunning = true;
            
            const rlhfData = [
                {
                    prompt: "–ù–∞–ø–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–∏–π –≤—ñ—Ä—à –ø—Ä–æ –≤–µ—Å–Ω—É.",
                    responses: [
                        { text: "–ö–≤—ñ—Ç–∏ —Ü–≤—ñ—Ç—É—Ç—å, —Å–æ–Ω—Ü–µ –≥—Ä—ñ—î, —Ä–∞–¥—ñ—Å—Ç—å —É—Å—ñ–º.", chosen: true },
                        { text: "–í–µ—Å–Ω–∞. –î–µ—Ä–µ–≤–∞. –ö–≤—ñ—Ç–∏.", chosen: false }
                    ]
                },
                {
                    prompt: "–Ø–∫ –±—É—Ç–∏ –±—ñ–ª—å—à –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–∏–º?",
                    responses: [
                        { text: "–ü—Ä–æ—Å—Ç–æ —Ä–æ–±–∏ –±—ñ–ª—å—à–µ.", chosen: false },
                        { text: "–°—Ç–≤–æ—Ä—é–π—Ç–µ —Å–ø–∏—Å–∫–∏ –∑–∞–≤–¥–∞–Ω—å, —Ä–æ–∑—Å—Ç–∞–≤–ª—è–π—Ç–µ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–∏ —Ç–∞ —Ä–æ–±—ñ—Ç—å –ø–µ—Ä–µ—Ä–≤–∏.", chosen: true }
                    ]
                }
            ];

            workingArea.innerHTML = `
                <div class="rlhf-vis-container">
                    <div class="rlhf-main" id="rlhf-main">
                        <div class="rlhf-prompt-area">
                            <div class="vis-prompt-box">
                                <strong>–ó–∞–ø–∏—Ç:</strong>
                                <div id="vis-prompt-text-rlhf"></div>
                            </div>
                        </div>
                        <div class="rlhf-model-area">
                             <div class="vis-model-icon" id="rlhf-model-icon">üß†</div>
                             <div>–û—Å–Ω–æ–≤–Ω–∞ –ú–æ–¥–µ–ª—å</div>
                        </div>
                        <div class="rlhf-interaction-area">
                            <div id="rlhf-responses-list"></div>
                            <div class="blinking-question-mark" id="rlhf-question-mark">?</div>
                        </div>
                         <div class="rlhf-reward-model-area">
                             <div class="vis-reward-model-icon">üèÖ</div>
                             <div>–ú–æ–¥–µ–ª—å –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∏</div>
                        </div>
                    </div>
                    <div class="vis-log" id="vis-log"></div>
                </div>`;

            const logArea = document.getElementById('vis-log');
            const mainArea = document.getElementById('rlhf-main');
            const promptText = document.getElementById('vis-prompt-text-rlhf');
            const responsesList = document.getElementById('rlhf-responses-list');
            const questionMark = document.getElementById('rlhf-question-mark');
            const modelIcon = document.getElementById('rlhf-model-icon');

            while(isVisRunning) {
                addToVisLog(logArea, "–ü–æ—á–∏–Ω–∞—î–º–æ —Ü–∏–∫–ª RLHF...");
                await wait(1500);

                for (const item of rlhfData) {
                    if (!isVisRunning) break;
                    
                    // Reset
                    responsesList.innerHTML = '';
                    questionMark.style.display = 'none';

                    promptText.textContent = item.prompt;
                    addToVisLog(logArea, `–ù–æ–≤–∏–π –∑–∞–ø–∏—Ç: "${item.prompt}"`);
                    await wait(1500);
                    if (!isVisRunning) break;

                    addToVisLog(logArea, "–ú–æ–¥–µ–ª—å –≥–µ–Ω–µ—Ä—É—î –∫—ñ–ª—å–∫–∞ –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ...");
                    responsesList.innerHTML = item.responses.map((r, i) =>
                        `<div class="rlhf-response" id="response-rlhf-${i}" data-chosen="${r.chosen}">${r.text}</div>`
                    ).join('');

                    const responseElements = Array.from(responsesList.querySelectorAll('.rlhf-response'));
                    for(const el of responseElements) {
                        await wait(100);
                        el.style.opacity = '1';
                        el.style.transform = 'scale(1)';
                    }
                    await wait(1500);
                    if (!isVisRunning) break;

                    addToVisLog(logArea, "–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –Ω–∞ –≤—ñ–¥–≥—É–∫ –ª—é–¥–∏–Ω–∏...");
                    questionMark.style.display = 'block';
                    await wait(2500);
                    if (!isVisRunning) break;
                    questionMark.style.display = 'none';

                    addToVisLog(logArea, "–í—ñ–¥–≥—É–∫ –æ—Ç—Ä–∏–º–∞–Ω–æ! –í–∏–∑–Ω–∞—á–∞—î–º–æ –∫—Ä–∞—â—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å.");
                    let chosenEl = null;
                    for (const el of responseElements) {
                        if (el.dataset.chosen === "true") {
                            el.classList.add('chosen');
                            chosenEl = el;
                        } else {
                            el.classList.add('not-chosen');
                        }
                    }
                    await wait(1500);
                    if (!isVisRunning) break;
                    
                    addToVisLog(logArea, "–ú–æ–¥–µ–ª—å –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏ –ø–æ—Å–∏–ª–∞—î –ø–æ–∑–∏—Ç–∏–≤–Ω–∏–π —Å–∏–≥–Ω–∞–ª.");
                    const signal = document.createElement('div');
                    signal.className = 'rlhf-reward-signal';
                    signal.textContent = 'üëç';
                    mainArea.appendChild(signal);

                    const chosenRect = chosenEl.getBoundingClientRect();
                    const modelRect = modelIcon.getBoundingClientRect();
                    const mainRect = mainArea.getBoundingClientRect();

                    signal.style.top = `${chosenRect.top - mainRect.top + chosenRect.height/2}px`;
                    signal.style.left = `${chosenRect.left - mainRect.left + chosenRect.width/2}px`;

                    await wait(50);
                    signal.style.opacity = '1';
                    signal.style.top = `${modelRect.top - mainRect.top + modelRect.height/2}px`;
                    signal.style.left = `${modelRect.left - mainRect.left + modelRect.width/2}px`;
                    
                    await wait(800);
                    if (!isVisRunning) { if(mainArea.contains(signal)) mainArea.removeChild(signal); break; }
                    
                    addToVisLog(logArea, "–û—Å–Ω–æ–≤–Ω–∞ –º–æ–¥–µ–ª—å –æ–Ω–æ–≤–ª—é—î—Ç—å—Å—è –Ω–∞ –æ—Å–Ω–æ–≤—ñ –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏.");
                    modelIcon.style.transition = 'transform 0.3s';
                    modelIcon.style.transform = 'scale(1.2)';
                    if(mainArea.contains(signal)) mainArea.removeChild(signal);

                    await wait(400);
                    modelIcon.style.transform = 'scale(1)';
                    await wait(2500);
                    if (!isVisRunning) break;
                }
                if (!isVisRunning) break;
                addToVisLog(logArea, "–í—Å—ñ –ø—Ä–∏–∫–ª–∞–¥–∏ –æ–±—Ä–æ–±–ª–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...");
                await wait(2000);
            }

        }

        // --- END: Visualization Functions ---

        // --- START: Call Visualization on initial load ---
        startDataCollectionVisualization();
        // --- END: Call Visualization on initial load ---

        function startDrag(e) {
            isDragging = true;
            document.body.style.cursor = 'grabbing';
            previousLevelIndex = currentLevelIndex;
            startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            dragMode = (e.target === handle) ? 'pending' : 'horizontal';
            segments.forEach((seg, i) => {
                seg.classList.remove('active');
                seg.style.height = '0px';
                seg.style.top = `${dotPositions[i]}px`;
            });
        }

        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            dragMode = 'none';
            document.body.style.cursor = 'default';
            handle.classList.remove('grabbing', 'flowing');
            clearTimeout(flowTimer);
            segments.forEach((seg, i) => {
                seg.classList.remove('active');
                setTimeout(() => {
                    if (!isDragging) {
                         seg.style.height = '0px';
                         seg.style.top = handle.style.top;
                    }
                }, 300);
            });
        }

        function onDrag(e) {
            if (!isDragging) return;

            const currentX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

            if (dragMode === 'pending') {
                const deltaX = Math.abs(currentX - startX);
                const deltaY = Math.abs(currentY - startY);
                if (deltaY > 10) dragMode = 'vertical';
                else if (deltaX > 10) dragMode = 'horizontal';
                else return;
            }

            if (dragMode === 'vertical') {
                e.preventDefault();

                const scrollerRect = scroller.getBoundingClientRect();
                const mouseY = currentY - scrollerRect.top;
                let closestDotY = dotPositions.reduce((prev, curr) => (Math.abs(curr - mouseY) < Math.abs(prev - mouseY) ? curr : prev));
                handle.style.top = `${closestDotY}px`;

                let closestIndex = dotPositions.indexOf(closestDotY);
                if (closestIndex !== -1 && closestIndex !== currentLevelIndex) {
                    handle.classList.add('grabbing', 'flowing');
                    clearTimeout(flowTimer);
                    flowTimer = setTimeout(() => {
                        handle.classList.remove('flowing', 'grabbing');
                        segments.forEach(seg => seg.classList.remove('active'));
                    }, 400);

                    const direction = closestIndex > currentLevelIndex ? 1 : -1;
                    const transitionDelay = 200;
                    const slideDistance = 15;

                    titleEn.style.opacity = 0;
                    titleEn.style.transform = `translateY(${direction * slideDistance}px)`;
                    titleUa.style.opacity = 0;
                    titleUa.style.transform = `translateY(${direction * slideDistance}px)`;

                    currentLevelIndex = closestIndex;

                    const startIdx = Math.min(previousLevelIndex, currentLevelIndex);
                    const endIdx = Math.max(previousLevelIndex, currentLevelIndex);

                    segments.forEach((segment, i) => {
                        if (i >= startIdx && i < endIdx) {
                            segment.style.top = `${dotPositions[i]}px`;
                            segment.style.height = `${dotPositions[i+1] - dotPositions[i]}px`;
                            segment.classList.add('active');
                        } else {
                            segment.style.height = '0px';
                            segment.classList.remove('active');
                        }
                    });

                    // --- START: Visualization Trigger Logic ---
                    if (previousLevelIndex !== currentLevelIndex) {
                        clearVisualization(); // Clear any running visualization first
                        setTimeout(() => { // Use a timeout to let the old one clear fully
                            if (currentLevelIndex === 6) {
                                startDataCollectionVisualization();
                            } else if (currentLevelIndex === 5) {
                                startPreprocessingVisualization();
                            } else if (currentLevelIndex === 4) {
                                startTokenizationVisualization();
                            } else if (currentLevelIndex === 3) {
                                startUnsupervisedPretrainingVisualization();
                            } else if (currentLevelIndex === 2) {
                                startSupervisedFinetuningVisualization();
                            } else if (currentLevelIndex === 1) {
                                startRewardModelTrainingVisualization();
                            } else if (currentLevelIndex === 0) {
                                startRLHFVisualization();
                            }
                        }, 10); // A tiny delay is enough
                    }
                    // --- END: Visualization Trigger Logic ---

                    previousLevelIndex = currentLevelIndex;

                    setTimeout(() => {
                        titleEn.textContent = levelData[currentLevelIndex].en;
                        titleUa.textContent = levelData[currentLevelIndex].ua;
                        titleEn.style.transition = 'none';
                        titleUa.style.transition = 'none';
                        titleEn.style.transform = `translateY(${-direction * slideDistance}px)`;
                        titleUa.style.transform = `translateY(${-direction * slideDistance}px)`;
                        titleEn.offsetHeight;
                        titleEn.style.transition = 'opacity 0.2s ease-in-out, transform 0.2s ease-in-out';
                        titleUa.style.transition = 'opacity 0.2s ease-in-out, transform 0.2s ease-in-out';
                        titleEn.style.opacity = 1;
                        titleEn.style.transform = 'translateY(0)';
                        titleUa.style.opacity = 1;
                        titleUa.style.transform = 'translateY(0)';
                    }, transitionDelay);
                }
            }
            
            if (dragMode === 'horizontal') {
                e.preventDefault();
                const screenWidth = window.innerWidth;
                const isRightSide = topGroup.classList.contains('right');
                const dragDistance = currentX - startX;
                const minDrag = (screenWidth / 2) - 10;

                if (isRightSide && dragDistance < -minDrag) {
                    topGroup.classList.remove('right');
                    mainContentWrapper.classList.remove('right');
                    endDrag(e);
                } else if (!isRightSide && dragDistance > minDrag) {
                    topGroup.classList.add('right');
                    mainContentWrapper.classList.add('right');
                    endDrag(e);
                }
            }
        }

        // Event Listeners
        scroller.addEventListener('mousedown', startDrag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', onDrag);
        scroller.addEventListener('touchstart', startDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchmove', onDrag);
    });
</script>
</body>
</html>
